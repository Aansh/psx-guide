\documentclass[a4paper]{article}

\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{microtype}

\lstdefinelanguage{Rust}%
  {
   morekeywords={abstract,alignof,as,become,box,%
                 break,const,continue,crate,do,%
                 else,enum,extern,false,final,%
                 fn,for,if,impl,in,%
                 let,loop,macro,match,mod,%
                 move,mut,offsetof,override,priv,%
                 proc,pub,pure,ref,return,%
                 Self,self,sizeof,static,struct,%
                 super,trait,true,type,typeof,%
                 unsafe,unsized,use,virtual,where,%
                 while,yield},%
   sensitive,%
   morekeywords=[1]{\$},%
   morecomment=[s]{/*}{*/},%
   morecomment=[l]//,%
   morestring=[b]",%
   morestring=[b]',%
  }[keywords,comments,strings]

\lstdefinelanguage{assembly}%
  {
    morekeywords={nop,lui,move,%
                 j,jal,jr,jalr,%
                 add,addu,addiu,addi,subu,%
                 sll,sra,srl,slt,sltu,slti,sltiu,%
                 sllv,srlv,srav,%
                 sw,sh,sb,or,ori,and,andi,nor,%
                 mtc0,mtc1,mtc2,mtc3,%
                 mfc0,mfc1,mfc2,mfc3,%
                 li,lw,lh,lhu,lb,lbu,lwl,lwr,%
                 beq,bne,bgtz,blez,%
                 bltz, bltzal, bgez, bgezal,%
                 div,divu,mul,multu,mflo,mfhi,mtlo,mthi,%
                 syscall,break,rfe,
                 },%
   sensitive,%
   moredelim=[s]{::}{::},%
   morecomment=[s]{/*}{*/},%
   morestring=[b]",%
   morestring=[b]',%
  }[keywords,comments,strings]

\definecolor{comment}{rgb}{0,0.6,0}
\definecolor{string}{rgb}{0.58,0,0.82}

\lstset{ %
  basicstyle=\footnotesize,
  columns=fixed,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{comment},
  frame=single
  keepspaces=true,
  keywordstyle=\color{blue},
  language=Rust,
  numbers=none,
  stringstyle=\color{string},
  tabsize=4,
}

\newcommand{\commit}[1] {%
  \medskip
  \framebox{You can get the current version of the emulator in
    \href{https://github.com/simias/psx-rs/commit/#1}{commit
      \texttt{#1}}}
  \medskip}

\newcommand{\code}[1] {\texttt{#1}}

\title{Playstation Emulation Guide}
\date{\today}
\author{Lionel Flandrin}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Introduction}

This is my attempt at documenting my implementation of a PlayStation
emulator from scratch. I'll write the document as I go and I'll try to
explain as much as possible along the way. You can find the complete
source of the emulator itself in my
\href{https://github.com/simias/psx-rs}{GitHub repository}.

Since my favourite passtime is to reinvent the wheel and recode things
that already exist I decided that this time I might as well document
it. This way maybe this time something useful will come out of it and
it'll give me a motivation to finish it.

I will be using the Rust programming language but this is not meant as
a Rust tutorial and knowledge of the language shouldn't be necessary
to follow this guide, although it won't hurt.

\subsection{Isn't emulation complicated?}

Emulation requires some low-level knowledge about how computers work
and some basics in electronics might help for certain things. Since
this doc is meant as an introduction to emulation I'll assume that the
reader doesn't bring anything with them beyond some decent programming
skills. So don't worry if you're not familiar with registers, cache,
memory mapped IO, virtual memory, interrupts and other low level fun:
I'll try to explain everything when needed. Emulators are a good
introduction to low level programming without having to bother with
that pesky hardware in person!

Since this is supposed to be a general guide about writing PlayStation
emulators I won't put the entire source code of the emulator here,
only snippets relevant to the matter beind discussed.

Finally, keep in mind that getting a PlayStation emulator even capable
to run \emph{some} games decently will require quite a lot of work. Don't
expect to play Final Fantasy VII on your brand new emulator in two
days. If you want to start with something simpler to see if you have a
taste for it you can search for Chip-8, Game Boy or NES emulation
tutorials (by increasing complexity).

\subsection{Feedback}

If some part of this document is unclear, poorly written or incomplete
please submit an issue so that I can fix or complete it. Corrections
for grammar, syntax and typos are very welcome. Thank you!

Ready? Let's begin!

\section{The CPU and the memory}

\subsection{What is a CPU, anyway?}

That might seem like a silly question to some but I'm sure there are
plenty of competent programmers out there who are used to program in
high level managed environements haven't seen a register in their
entire life. Let me make the introductions.

For our first version of the PlayStation CPU I'm going to make some
simplifying assumptions. I'm going to ignore the caches for instance
and assume that it directly accesses the system bus. Basically we're
going to implement a
\href{https://en.wikipedia.org/wiki/Von_Neumann_architecture}{Von
 Neumann architecture}.As we make progress we'll have to revisit this
design to add the missing bits when they are needed.

The objective of this section is to implement all the instructions and
try to reach the part of the BIOS where it starts to draw on the
screen. As we'll see there's a bunch of boring initialization code to
run before we get there.

There are 67 opcodes in the Playstation MIPS CPU. Some take one line
to implement, others will give us more trouble. In order to make the
process more interactive and less tedious we'll implement them as
they're encountered while we're running the original BIOS code. This
way we'll immediately be able to see our emulator in action.

But first things first, before we start implementing instructions we
need to explain how a CPU works.

\subsection{Architecture}

A simple Von Neumann architecture looks like this: the CPU only sees a
flat address space: an array of bytes. The PlayStation uses 32bit
addresses so the CPU sees \code{1 << 32} addresses. In other words it
can address 4GB of memory. That's why the PlayStation is said to be a
32bit console (that and the fact that it uses 32bit registers in the
CPU as we'll see in a minute).

This address space contains all the external ressources the CPU can
access: the RAM of course but also the various peripherals (GPU,
controllers, CD drive, BIOS...). That's called
\href{https://en.wikipedia.org/wiki/Memory-mapped_I/O}{memory mapped
  IO}. Note that in this context "memory" doesn't mean RAM. Rather it
means that you access peripherals as if they were memory (instead of
using dedicated instructions for instance). From the point of view of
the CPU, everything is just a big array of bytes and it doesn't really
know what's out there.

Of course we'll have to figure out how the devices and RAM are mapped
in this address space to make sure the transactions end up at the
right location when the CPU starts reading and writing to the bus. But
first we need to understand how the code is executed.

\subsection{The code}

In this architecture the instructions live in the global address space
along with everything else. Typically in RAM but again, the CPU
doesn't care. If you want to run code from the controller input port
I'm sure the console will let you. Probably not very useful but it's
all the same as far as the CPU is concerned.

So somewhere in this 4GB address space there's the next instruction
for the CPU to run. How does it know the address of this instruction?
By using a register of course!

\subsection{The Program Counter register}

\href{https://en.wikipedia.org/wiki/Processor_register}{Registers} are
very small and very fast special purpose memories built inside the
CPU. Most CPU instructions manipulate those registers by adding them,
multiplying them, masking them, storing their content to memory or
fetching it back\dots{}

\href{https://en.wikipedia.org/wiki/Program_counter}{The Program
  Counter} (henceforth refered to as PC) is one of the most
elementary registers, it exists in one form or an other on basically
all computer architectures (although it goes by various names, on x86
for instance it's called the Instruction Pointer, IP). Its
job is simply to hold the address of the next instruction to be run.

As we've seen, the PlayStation uses 32bit addresses, so the PC
register is 32bit wide (as are all other CPU registers for that
matter).

A typical CPU execution cycle goes roughly like this:

\begin{enumerate}
  \item Fetch the instruction located at address PC,
  \item Increment the PC to point to the next instruction,
  \item Execute the instruction,
  \item Repeat
\end{enumerate}

We need to know how big an instruction is in order to know how many
bytes to fetch and how much we need to increment the PC to
point at the next instruction. Some architectures have variable length
instructions (x86 and derivatives are a common example) which means
we'd have to decode the instruction to know how many bytes it
takes. Fortunately for us, the PlayStation uses a fixed length
instruction set
(\href{https://en.wikipedia.org/wiki/MIPS_instruction_set}{The MIPS
  instruction set}) and all instructions are 32bit long.

With all that in mind we can finally start writing some code!

Here's what the CPU state looks like at that point:

\begin{lstlisting}
/// CPU state
pub struct Cpu {
    /// The program counter register
    pc: u32,
}
\end{lstlisting}

And here's the implementation of our CPU cycle described above:

\begin{lstlisting}
impl Cpu {

    pub fn run_next_instruction(&mut self) {
        let pc = self.pc;

        // Fetch instruction at PC
        let instruction = self.load32(pc);

        // Increment PC to point to the next instruction.
        self.pc = pc.wrapping_add(4);

        self.decode_and_execute(instruction);
    }
}
\end{lstlisting}

In Rust \code{wrapping\_add} means that we want the PC to
wrap back to 0 in case of an overflow (i.e. \code{0xfffffffc + 4 =>
0x00000000}). We'll see that most CPU operations wrap on overflow
(although some instructions catch those overflows and generate an
exception, we'll see that later). The PC is no exception.

If you're coding in C you don't need to worry about that if you use
\code{uint32\_t} since the C standard mandates that unsigned overflow wraps
around in this fashion. Rust however says that overflows are undefined
and will generate an error in debug builds if an unchecked overflow is
detected, that's why I need to write \code{pc.wrapping\_add(4)} instead of
\code{pc + 4}.

We now finally have some code but it doesn't build yet.

We're still missing 3 pieces of the puzzle before we can run this
piece of code:

\begin{itemize}
 \item What's the initial value of PC when starting up?
 \item How do we implement the \code{fetch32} function?
 \item How do we implement the \code{decode\_and\_execute} function?
\end{itemize}

\subsubsection{Reset value of the PC}

In integrated circuits
\href{https://en.wikipedia.org/wiki/Reset_%28computing%29}{reset} is a
state where the chip generally does nothing and its internal state
is set to some known default ``factory'' value. What exactly the
reset does varies from chip to chip (it's just a convention) but
it's assumed that a chip will restart in a clean and deterministic
state after a reset cycle.

Generally the reset is a dedicated pin on the chip that's connected to
a button or some other control logic. Sometimes you can also request a
"soft" reset through software using a specific command or sequence of
instructions. Reseting a chip does necessitate cutting off the power
(nor is power cycling an integrated circuit a good way to reset a
chip: if the reset signal is not asserted it might not load the
default values correctly).

When you power up the console or hit the reset button the hardware
forces the CPU (and other peripherals) into a reset state to
initialize the logic.

Knowing this it's pretty obvious that the reset value of the
PC is very important since it's going to tell the CPU where
it should start running the code. It basically defines the location of
the "main" function of the console's kernel.

The docs say that the reset value of PC is
\code{0xbfc00000}. In the playstation memory map that's the
beginning of the BIOS (we'll look at the memory map in greater details
in the next section).

Now that we know where our story starts we can write our CPU
initializer:

\begin{lstlisting}
impl Cpu {

    pub fn new() -> Cpu {
     	Cpu {
            // PC reset value at the beginning of the BIOS
            pc: 0xbfc00000,
        }
    }

    //...
}
\end{lstlisting}

\subsection{The Playstation memory map}

Our CPU treats all addresses the same way but at some point we'll have
to dispatch the load/store requests to the correct peripheral. If we
read the BIOS and we get GPU data instead we're going to run into
troubles very quickly\dots{}

So how do we know what is mapped at some arbitrary address? By using
the \href{https://en.wikipedia.org/wiki/Memory_map}{memory map} of
course!

Here's an overview of the PlayStation memory map, courtesy of
\href{http://problemkaputt.de/psx-spx.htm#cpuspecifications}{the Nocash
  specs}:

\begin{table}[ht]
  \centering

  \begin{tabular}{ l | l | l | r | l }
    KUSEG & KSEG0 & KSEG1 & Length & Description \\
    \hline
    \code{0x00000000} & \code{0x80000000} & \code{0xa0000000} & 2048K
     & Main RAM \\
    \code{0x1f000000} & \code{0x9f000000} & \code{0xbf000000} & 8192K
     & Expansion Region 1 \\
    \code{0x1f800000} & \code{0x9f800000} & \code{0xbf800000} &    1K
     & Scratchpad \\
    \code{0x1f801000} & \code{0x9f801000} & \code{0xbf801000} &    8K
     & Hardware registers \\
    \code{0x1fc00000} & \code{0x9fc00000} & \code{0xbfc00000} &  512K
     & BIOS ROM \\
  \end{tabular}

  \caption{Playstation memory map}
  \label{tab:mmap}
\end{table}

Let's take the time to parse through this.

We can see that most peripherals in table~\ref{tab:mmap} are mapped at
several addresses. For instance if we look at the PC reset
value \code{0xbfc00000} corresponds to the beginning of the BIOS range in
region KSEG1. However we can also reach the same location through
addresses \code{0x1fc00000}(KUSEG) and \code{0x9fc00000}(KSEG0).

What's the point of having those mirrored regions? What's the
difference between KUSEG and KSEG1 for instance? Those are memory
regions which are used to specify certain attributes of the memory
access. On the Playstation hardware it's mostly used to specify
whether the access is cached or not.

For now we're going to ignore regions and treat all mappings the same,
we'll study them more closely later on.

\begin{table}[ht]
  \centering

  \begin{tabular}{ l | r | l }
    KSEG2 & Length & Description \\
    \hline
    \code{0xfffe0000} & 512B & I/O Ports \\
  \end{tabular}

  \caption{KSEG2 memory map}
  \label{tab:kseg2}
\end{table}

Table~\ref{tab:kseg2} shows the last region: KSEG2. It's a bit
different from the others. It doesn't mirror the other regions,
instead it gives access to a unique set of registers. As far as I know
the only important register there is the cache control but there might
be others I haven't encountered yet.

\subsubsection{Implementing the memory map}

In order to implement the PlayStation memory map in our emulator we
will need an interconnect to dispatch the load/store operations to the
correct peripheral.

I don't know if the PlayStation really has a hardware
interconnect. The CPU could just "broadcast" the read/write operations
on the system bus and the peripherals would check the address and only
answer if it's for them. However this design would be inefficient in
software: we'd need to iterate over the peripherals for each
transaction until we find the correct receiver.

Instead we're just going to implement a "switchboard" that will match
the address to the correct peripheral and forward it there.

Since the first thing the emulator will run is the BIOS we'll use it
as our first peripheral.

\subsection{The BIOS}

On the PlayStation the BIOS displays the first screens (with the logos
and that memorable sweeping tune) and starts the game from the CD
drive. If no CD is present it displays a menu that can be used to
manage the memory cards and play CDs. As a player that's probably the
only time you'd know there was a BIOS running.

But that's just the tip of the iceberg! The BIOS remains loaded at all
time and provides a Basic Input/Output System to the running
game. That means that the game can call into the BIOS to do things
like allocating memory, reading the memory card, common libc functions
(qsort, memset...) and many other things.

We won't be implementing the BIOS ourselves. It's possible (and it's
been done) but that's a lot of work and probably something you'd want
to do once you have a working emulator. It might also hurt
compatibility since many games are known to patch the BIOS at
runtime. The
\href{http://problemkaputt.de/psx-spx.htm#biospatches}{Nocash specs}
have more info.

We could dump the BIOS of a console but that requires access to the
actual hardware and the know-how to access the BIOS
memory. Fortunately some nice people have done it for us and these
days it's easy to find BIOS files on the web.

There are many BIOS versions: they change depending on the region, the
hardware revision and patches. Any good dump should work (after all,
they all do more or less the same thing) but if you're following this
guide it's probably better that we use the same file.

\begin{table}[ht]
  \centering

  \begin{tabular}{ l | l }
    Algorithm & Hash \\
    \hline
    MD5    & \code{924e392ed05558ffdb115408c263dccf} \\
    SHA-1   & \code{10155d8d6e6e832d6ea66db9bc098321fb5e8ebf} \\
  \end{tabular}

  \caption{\code{SCPH1001.BIN} BIOS checksums}
  \label{tab:checksums}
\end{table}

I've decided to go for the version named \code{SCPH1001.BIN}. The file
should be \emph{exactly} 512KB big. Check table~\ref{tab:checksums} to make
sure you got the right one.

\subsection{Loading the BIOS}

Once we got our BIOS the rest is pretty straightforward. We just read
the file into a 512KB buffer:

\begin{lstlisting}
/// BIOS image
pub struct Bios {
    /// BIOS memory
    data: Vec<u8>
}

impl Bios {

    /// Load a BIOS image from the file located at `path`
    pub fn new(path: &Path) -> Result<Bios> {

        let file = try!(File::open(path));

        let mut data = Vec::new();

        // Load the BIOS
        try!(file.take(BIOS_SIZE).read_to_end(&mut data));

        if data.len() == BIOS_SIZE as usize {
            Ok(Bios { data: data })
        } else {
            Err(Error::new(ErrorKind::InvalidInput,
                           "Invalid BIOS size"))
        }
    }
}

/// BIOS images are always 512KB in length
const BIOS_SIZE: u64 = 512 * 1024;
\end{lstlisting}

We also need to be able to read data from the BIOS. The CPU wants to
read 32bit of data to load the instructions so let's start by
implementing load32:

\begin{lstlisting}
impl Bios {
    // ...

    /// Fetch the 32bit little endian word at `offset`
    pub fn load32(&self, offset: u32) -> u32 {
        let offset = offset as usize;

        let b0 = self.data[offset + 0] as u32;
        let b1 = self.data[offset + 1] as u32;
        let b2 = self.data[offset + 2] as u32;
        let b3 = self.data[offset + 3] as u32;

        b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
    }
}
\end{lstlisting}

A few things to note: \code{offset}, as its name implies, is not the
absolute address used by the CPU, it's just the offset in the BIOS
memory range. Remember that the BIOS is mapped in multiple regions so
we'll handle that in the generic interconnect code. Each peripheral
will just handle offsets in its address range.

In the comment I mention that we read the word in \emph{little
  endian}. That's important. If you've never had to worry about
\href{https://en.wikipedia.org/wiki/Endianness}{endianess} issues
before let me give you the gist.

The basic unit of memory is a byte (8 bits in our case). You cannot
address anything smaller than that. However sometimes you need to
store data over multiple bytes. For instance we've seen that our
instructions are 4byte long. We have multiple way to store 4byte words
in our "array of bytes".

Let's take an example: you have the 32bit word
\code{0x12345678}. You have multiple way to store that value in 4
consecutive bytes. We can store [0x12, 0x34, 0x56, 0x78] or
[0x78, 0x56, 0x34, 0x12] for instance. The former is called
\emph{big-endian} because we store the most significant byte
first. The latter is \emph{little-endian} because we store the least
significant byte first. There are other endian types with weirder
patterns but they're not often used is modern computers. Check
wikipedia if you want more details.

The PlayStation is little-endian so we're in the 2nd case: when
reading or writing multi-byte values the least significiant byte goes
first. If we do it the other way around we'll end up with garbage.

Now we can implement our interconnect to let the CPU communicate with
the BIOS.

\subsection{The interconnect}

We now have an embryo of a CPU and our first device ready to talk to
each other. We just need to figure out how to link them together.

At that point we could have the CPU talk directly to the BIOS, after
all it's our only device. Obviously that won't work for very long
however, we need to be able to dispatch the CPU's loads and stores to
the correct peripheral depending on the address range.

I'm not quite sure how this is handled on the actual hardware. For
simple buses it's very possible that the CPU just "broadcasts" the
address to all the peripherals and each of them just checks if it's
within their address range and simply ignores the transaction if they
see it's not for them. It's fast in hardware because all peripherals
work in parallel so there's no delay induced: they can all receive and
decode the address at the same moment.

Unfortunately we can't really do that in software: the closest
equivalent would be to spawn a thread for each peripheral. The problem
is that memory transactions are very common (several millions per
second potentially) and having to send data and resynchronize across
threads would kill our performances.

Multihreading emulators in general is a very tough issue: for
threading to be really efficient you need to reduce data exchange and
resynchronization as much as possible to let each thread live its
life. When we emulate however we want to mimick the original hardware
behaviour and speed as much as possible which requires very frequent
resynchronization and we have plenty of shared state. The two
endeavors are somewhat at odds. That's not to say multithreading is
impossible in emulators, just that it's hard. We can't just spawn
threads willy-nilly.

Anyway, back to our interconnect: since threads are out it means we'll
have to sequentially match the address against each mapping until we
get a match. Then we can let the selected peripheral handle the
transaction.

Let's do just that:

\begin{lstlisting}
/// Global interconnect
pub struct Interconnect {
    /// Basic Input/Output memory
    bios: Bios,
}

impl Interconnect {
    pub fn new(bios: Bios) -> Interconnect {
        Interconnect {
            bios: bios,
        }
    }
}
\end{lstlisting}

I've decided to store the BIOS directly in the interconnect
\code{struct}. We'll append the other peripherals there as we
implement them. We are going to store the interconnect inside the
\code{struct Cpu} which will give us a device tree with the CPU at
the top. It makes the data paths pretty simple: everything goes \emph{from}
the CPU \emph{to} the peripherals. It's easier to reason about than a full
``everybody sees everybody'' architecture in my opinion but it might
prove limiting as we progress. We'll see if we need to revise that
later.

Now we can finally implement the \code{load32} function that the CPU
will be using. I don't like having hardcoded constants all over the
place so I'm going to tie the address ranges to nice symbolic names:

\begin{lstlisting}
mod map {
    struct Range(u32, u32);

    impl Range {
        /// Return `Some(offset)` if addr is contained in `self`
        pub fn contains(self, addr: u32) -> Option<u32> {
            let Range(start, length) = self;

            if addr >= start && addr < start + length {
                Some(addr - start)
            } else {
                None
            }
        }
    }

    pub const BIOS: Range = Range(0xbfc00000, 512 * 1024);
}
\end{lstlisting}

If you're not familiar with rust what this does is create a new type
\code{Range} which is a tuple of two values: the start address and length
of the mapping.

I also declare a \code{contains} methods which takes an address and
returns \code{Some(offset)} if the address is within the range,
\code{None} otherwise. You can think of it as a form of multiple
return values with some nice type-safety on top.

Finally I declare our first range for the BIOS.

Now for the load32 function:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Load 32bit word at `addr`
    pub fn load32(&self, addr: u32) -> u32 {

        if let Some(offset) = map::BIOS.contains(addr) {
            return self.bios.load32(offset);
        }

        panic!("unhandled fetch32 at address {:08x}", addr);
    }
}
\end{lstlisting}

The \code{if let} syntax is an other rust nicety: if the
\code{contains} function returns \code{Some(offset)} we enter the
body of the if with \code{offset} bound to a temporary variable. If
\code{contains} returns \code{None} on the other hand the
\code{if} is refuted and we don't enter the body and go straight to
the \code{panic!} command which will make our emulator crash.

\subsection{Gluing the interconnect to the CPU}

The only thing left before we can finally build our code is gluing the
Interconnect with the Cpu.

We add an \code{inter} member to the \code{struct Cpu} and take an
\code{Interconnect} object in the constructor:

\begin{lstlisting}
/// CPU state
pub struct Cpu {
    /// The program counter register
    pc: u32,
    /// Memory interface
    inter: Interconnect,
}

impl Cpu {

    pub fn new(inter: Interconnect) -> Cpu {
        Cpu {
            // PC reset value at the beginning of the BIOS
            pc: 0xbfc00000,
            inter: inter,
        }
    }

    // ...
}
\end{lstlisting}

We can also implement the \code{load32} function for the CPU which
will just call the interconnect.

\begin{lstlisting}
impl Cpu {
    //...

    /// Load 32bit value from the interconnect
    fn load32(&self, addr: u32) -> u32 {
        self.inter.load32(addr)
    }
}
\end{lstlisting}

We're still lacking the \code{decode\_and\_execute} function, let's use a
placeholder function that just panics for now:

\begin{lstlisting}
impl Cpu {
    //...

    fn decode_and_execute(&mut self, instruction: u32) {
        panic!("Unhandled instruction {:08x}",
               instruction);
    }
}
\end{lstlisting}

Finally we can instantiate everything in our \code{main} function:

\begin{lstlisting}
fn main() {
    let bios = Bios::new(&Path::new("roms/SCPH1001.BIN")).unwrap();

    let inter = Interconnect::new(bios);

    let mut cpu = Cpu::new(inter);

    loop {
        cpu.run_next_instruction();
    }
}
\end{lstlisting}

I've hardcoded the BIOS path for now. It would be better to read it
from the command line, a config file or even some fancy dialog window
but it'll do nicely for now.

We should now be able to build the code. When I run it, assuming that
the BIOS file was found at the correct location I get:

\begin{verbatim}
thread `<main>' panicked at 'Unhandled instruction 3c080013'
\end{verbatim}

As expected the \code{decode\_and\_execute} function died on us but
we managed to fetch an instruction. If you've been using the same BIOS
file as me you should have exactly the same value of
\code{0x3c080013}. If you got an other value something is wrong with
your code. In particular if you end up with \code{0x1300083c} it
means you're erroneously reading in big-endian.

\subsection{Instruction decoding}

We've now fetched our first instruction from the BIOS:
\code{0x3c080013}. What do we do with this?

In order to be able to run this instruction we need to decode it to
figure out what it means. Instruction encoding is of course CPU
dependent so we need to interpret this value in the context of the
Playstation \href{https://en.wikipedia.org/wiki/R3000}{R3000}
processor. Once again the
\href{http://problemkaputt.de/psx-spx.htm#cpuspecifications}{Nocash
  specs} have our back and list the format of the
instruction. \href{https://en.wikipedia.org/wiki/MIPS_instruction_set}{MIPS}
is a common architecture used outside of the playstation and you can
find plenty of resources online describing its \href{https://en.wikipedia.org/wiki/Instruction_set}{instruction set}.

Let's decode this one by hand to see how this works. If we look at the
``Opcode/Parameter Encoding'' table in Nocash's docs we see that we
need to look at the bits [31:26] of the operation to see what type it
is. In our case they are \code{001111}. That means the operation is
a \code{LUI} or ``Load Upper Immediate''. \emph{Immediate} means
that the value loaded is directly in the instruction, not indirectly
somewhere else in memory. \emph{Upper} means that it's loading this
immediate value into the high 16 bits of the target register. The 16
low bits are cleared (set to 0).

But what are the register and the value used by the instruction? Well
we need to finish decoding it to figure it out: for a \code{LUI}
bits [20:16] give us the target register: in our case it's
\code{01000} which means it's register 8. Finally bits [15:0]
contain the immediate value: \code{0000 0000 0001 0011} or 19 in
decimal. Bits [25:21] are not used and their value doesn't matter.

In other words this instruction puts \code{0x13} in the 16 high bits
of the register 8. In MIPS assembly\footnote{I'm using the GNU
  assembler syntax in this guide unless otherwise noted.} it would be
equivalent to:

\begin{lstlisting}[language=assembly]
lui $8, 0x13
\end{lstlisting}

Enough babbling, let's implement decoding. First I'll wrap the raw
instruction in a nice interface that will let us extract the fields
without doing the bitshifts and masking everywhere. If you look at the
encoding for other MIPS instructions you'll see that it's fairly
regular, for instance immediate values are always stored in the LSBs:

\begin{lstlisting}
struct Instruction(u32);

impl Instruction {
    /// Return bits [31:26] of the instruction
    fn function(self) -> u32 {
        let Instruction(op) = self;

        op >> 26
    }

    /// Return register index in bits [20:16]
    fn t(self) -> u32 {
        let Instruction(op) = self;

        (op >> 16) & 0x1f
    }

    /// Return immediate value in bits [16:0]
    fn imm(self) -> u32 {
        let Instruction(op) = self;

        op & 0xffff
    }
}
\end{lstlisting}

The names for the accessor functions match those I've seen used in the
various references to name the various fields.

We can now leverage that fancy interface in
\code{decode\_and\_execute}:

\begin{lstlisting}
impl Cpu {
     // ...

    fn decode_and_execute(&mut self, instruction: Instruction) {
        match instruction.function() {
            0b001111 => self.op_lui(instruction),
            _        => panic!("Unhandled instruction {:x}", instruction.0),
        }
    }

    /// Load Upper Immediate
    fn op_lui(&mut self, instruction: Instruction) {
        let i = instruction.imm();
        let t = instruction.t();

        panic!("what now?");
    }
}
\end{lstlisting}

We're very close to finally run our first instruction in full but
we're still missing something: we see that the register field in this
instruction is 5bits, that means it can index 32 registers. But for
now we only have one register in our CPU: the PC. We need to
introduce the rest of them.

\subsection{General purpose registers}

\begin{table}[ht]
  \centering

  \begin{tabular}{ l | l | l }
    Register         & Name             & Conventional use          \\
    \hline
    \$0              & \$zero           & Always zero               \\
    \$1              & \$at             & Assembler temporary       \\
    \$2, \$3         & \$v0, \$v1       & Function return values    \\
    \$4\dots{}\$7    & \$a0\dots{}\$a3  & Function arguments        \\
    \$8\dots{}\$15   & \$t0\dots{}\$t7  & Temporary registers       \\
    \$16\dots{}\$23  & \$s0\dots{}\$s7  & Saved registers           \\
    \$24, \$25       & \$t8, \$t9       & Temporary registers       \\
    \$26, \$27       & \$k0, \$k1       & Kernel reserved registers \\
    \$28             & \$gp             & Global pointer            \\
    \$29             & \$sp             & Stack pointer             \\
    \$30             & \$fp             & Frame pointer             \\
    \$31             & \$ra             & Function return address   \\
  \end{tabular}

  \caption{R3000 CPU general purpose registers}
  \label{tab:cpuregs}
\end{table}

Table~\ref{tab:cpuregs} lists the registers in the Playstation MIPS
R3000 CPU (ignoring the coprocessors for now). They're all 32bit
wide.

You can see that we have 32 registers (\$0 to \$31) which are the
\emph{general purpose} registers. They're all given a mnemonic used
when writing assembly. For instance, by convention, \$29 is the
\href{https://en.wikipedia.org/wiki/Call_stack}{stack pointer}(\$sp)
and \$30 holds the
\href{https://en.wikipedia.org/wiki/Call_stack#FRAME-POINTER}{frame
  pointer} (\$fp).

It's important to understand that those are just a convention between
developers, in the hardware there's no difference between \$29 and
\$30. The point of those
\href{https://en.wikipedia.org/wiki/Calling_convention}{calling
  conventions} is to make it possible to make code generated from
different compilers or written in assembly by different coders remain
interoperable. If you write MIPS assembly and want to call third party
functions (like the BIOS functions for instance) you'll have to adhere
to this convention.

Only two general purpose registers are given a special meaning by the
hardware itself: \$zero and \$ra.

\subsubsection{The \$zero register}

\$zero (\$0) is \emph{always} equal to 0. If an instruction attempts
to load a value in this register it doesn't do anything, the register
will still be 0 afterwards.

Having a constant 0 register is useful to reduce the size of the
instruction set. For instance if you want to move the value of the
register \$v0 in \$a0 you can write this:

\begin{lstlisting}[language=assembly]
move $a0, $v0
\end{lstlisting}

However this ``move'' instruction is not actually part of the MIPS
instruction set, it's just a convenient shorthand understood by the
assembler which will generate the equivalent instruction:

\begin{lstlisting}[language=assembly]
addu $a0, $v0, $zero
\end{lstlisting}

We can see that it effectively does the same thing by setting \$a0 to
the result of \$v0 + 0 but we avoid having to implement a dedicated
``move'' instruction in the CPU.

\subsubsection{The \$ra register}

\$ra (\$31) is the other general purpose register given a special
meaning by the hardware since instructions like ``jump and link'' or
``branch and link'' put the return address in this register
exclusively. Therefore the following instruction jumps in function
\code{foo} and puts the return address in \$ra:

\begin{lstlisting}[language=assembly]
jal foo
\end{lstlisting}

As we'll soon see we don't really have to bother with the various
roles assigned to those general purpose registers when writing our
emulator (with the exception of \$zero and \$ra) but it's still useful
to know the convention when trying to understand what some emulated
code is doing.

\subsection{Special purpose registers}

\begin{table}[ht]
  \centering

  \begin{tabular}{ l | l }
    Name        & Description     \\
    \hline
    PC          & Program counter \\
    HI          & high 32bits of multiplication result; remainder of
                  division \\
    LO          & low 32bits of multiplication result; quotient of
                  division \\
  \end{tabular}

  \caption{R3000 CPU special purpose registers}
  \label{tab:specialcpuregs}
\end{table}

Table~\ref{tab:specialcpuregs} lists the three \emph{special purpose}
CPU registers. We're already familiar with the PC used to keep track
of the code execution. The two others are HI and LO which contain the
results of multiplication and division instructions. Those cannot be
used as general purpose registers, instead there are special
instructions used to manipulate them. We'll discover them as we
implement them.

\subsection{Implementing the general purpose registers}

I'm just going to represent the 32 general purpose registers as an
array of 32 \code{u32} and use the index in the instructions to
address them. I'll even have an entry for \$zero even though it's
always 0 to avoid special cases. Of course we'll have
to be careful to always keep its value to 0.

\begin{lstlisting}
/// CPU state
pub struct Cpu {
    /// The program counter register
    pc: u32,
    /// General Purpose Registers.
    /// The first entry must always contain 0.
    regs: [u32; 32],
    /// Memory interface
    inter: Interconnect,
}
\end{lstlisting}

The registers are not initialized on reset, so they contain garbage
value when we start up. For the sake of our emulator being
deterministic I won't actually put random values in the registers
however, instead I'm going to use an arbitrary garbage value
\code{0xdeadbeef}. We could as well initialize them to 0 but I
prefer to use a more distinguishable value which can be helpful while
debugging. We must remember to put 0 in \$zero however.

\begin{lstlisting}
impl Cpu {
    pub fn new(inter: Interconnect) -> Cpu {
        // Not sure what the reset values are...
        let mut regs = [0xdeadbeef; 32];

        // ... but R0 is hardwired to 0
        regs[0] = 0;

        Cpu {
            // PC reset value at the beginning of the BIOS
            pc: 0xbfc00000,
            regs: regs,
            inter: inter,
        }
    }

    fn reg(&self, index: u32) -> u32 {
        self.regs[index as usize]
    }

    fn set_reg(&mut self, index: u32, val: u32) {
        self.regs[index as usize] = val;

        // Make sure R0 is always 0
        self.regs[0] = 0;
    }

    // ...
}
\end{lstlisting}

I've also added a getter and a setter. They're very straightforward
but I take care to always write 0 in \$zero in case it gets
overwritten. I don't ever bother checking if the function wrote in
this register or an other one, writing a 32bit value is cheap and
probably cheaper than adding an \code{if}.

\subsection{LUI instruction}

Now we can finally implement our first instruction in full! Here's
what \code{op\_lui} looks like now:

\begin{lstlisting}
impl Cpu {

    // ...

    /// Load Upper Immediate
    fn op_lui(&mut self, instruction: Instruction) {
        let i = instruction.imm();
        let t = instruction.t();

        // Low 16bits are set to 0
        let v = i << 16;

        self.set_reg(t, v);
    }
}
\end{lstlisting}

Note that the low 16bits are set to 0. It's important as we'll see
with the next instruction.

The first instruction in the BIOS uses LUI to put 0x13 in the high
16bits of \$8.

\subsection{ORI instruction}

We can directly implement the 2nd instruction: \code{0x3508243f}.

It decodes to:

\begin{lstlisting}[language=assembly]
ori $8, $8, 0x243f
\end{lstlisting}

In other words, it puts the result of the \emph{bitwise or} of \$8 and
0x243f back into \$8. The previous LUI initialized the high
16bits of \$8 and set the rest to 0 so this one will initialize the
low 16bits.

That's the simplest way to load a constant in a register with the MIPS
instruction set and that's why it's important for LUI to set the low
16bits to 0, otherwise the ORI wouldn't do the right thing.

The implementation is straightforward:

\begin{lstlisting}
impl Cpu {
    // ...

    fn decode_and_execute(&mut self, instruction: Instruction) {
        match instruction.function() {
            0b001111 => self.op_lui(instruction),
            0b001101 => self.op_ori(instruction),
            _        => panic!("Unhandled instruction {:x}",
                               instruction.0),
        }
    }

    /// Bitwise Or Immediate
    fn op_ori(&mut self, instruction: Instruction) {
        let i = instruction.imm();
        let t = instruction.t();
        let s = instruction.s();

        let v = self.reg(s) | i;

        self.set_reg(t, v);
    }
}
\end{lstlisting}

After those two instructions the value of \$8 should be
\code{0x0013243f}. The next instruction as an other LUI which puts
\code{0x1f800000} in \$1.

\subsection{Writing to memory}

The next instruction, \code{0xac281010}, is going to give us a
little more trouble. It decodes to the ``store word'' instruction:

\begin{lstlisting}[language=assembly]
sw $8, 0x1010($1)
\end{lstlisting}

If you're not familiar with GNU assembly syntax the
\code{0x1010(\$1)} syntax means ``address in \$1 plus offset
0x1010''. In this case the full instruction is ``store the 32bits in
register \$8 at the location \$1 + 0x1010''. Given the current values
of the \$1 and \$8 registers it would store \code{0x0013243f} at the
address \code{0x1f801010}.

We can implement the storing to memory by mirroring our
\code{load32} code:

\begin{lstlisting}
impl Cpu {
    // ...

    /// Store 32bit value into the memory
    fn store32(&mut self, addr: u32, val: u32) {
        self.inter.store32(addr, val);
    }

    fn decode_and_execute(&mut self, instruction: Instruction) {
        match instruction.function() {
            0b001111 => self.op_lui(instruction),
            0b001101 => self.op_ori(instruction),
            0b101011 => self.op_sw(instruction),
            _        => panic!("Unhandled instruction {:x}", instruction.0),
        }
    }

    // ...

    /// Store Word
    fn op_sw(&mut self, instruction: Instruction) {
        let i = instruction.imm();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);
        let v    = self.reg(t);

        self.store32(addr, v);
    }
}
\end{lstlisting}

This code for \code{op\_sw} is actually subtly broken, I'll explain
why in a moment. For these values of \code{addr} and \code{i}
it'll do the right thing though. You can see that we call into the
interconnect's \code{store32} method that we have yet to
implement. Since the only peripheral we support so far is the BIOS ROM
and we
\href{https://github.com/simias/psx-hardware-tests/blob/master/tests/bios_write/main.s}{can't
  write to it} there's not much we can do at that point, let's just
log the access and panic:

\begin{lstlisting}
impl Interconnect {
    // ...

    /// Store 32bit word `val` into `addr`
    pub fn store32(&mut self, addr: u32, val: u32) {
        panic!("unhandled store32 into address {:08x}", addr);
    }
}
\end{lstlisting}

\subsubsection{Unaligned memory access}

While we're at it I just realized that so far we allow 32bit fetch and
store from and to any address. However the architecture won't allow
unaligned memory accesses (i.e. 32bit accesses must have an address
which is a multiple of 32bits). Many architectures don't support
unaligned accesses (it generates a ``bus error'') and those who do
usually implement it at a cost (unaligned accesses are slower). I'd
rather add some code in the functions to catch unaligned access, it
could help us catch unexpected behaviours when debugging:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Load 32bit word at `addr`
    pub fn load32(&self, addr: u32) -> u32 {

        if addr % 4 != 0 {
            panic!("Unaligned load32 address: {:08x}", addr);
        }

        //...
    }

    /// Store 32bit word `val` into `addr`
    pub fn store32(&mut self, addr: u32, val: u32) {

        if addr % 4 != 0 {
            panic!("Unaligned store32 address: {:08x}", addr);
        }

	//...
    }
}
\end{lstlisting}

Once we implement exceptions we'll be able to handle those conditions
properly.

The code should now compile but unsurprisingly it won't manage to
execute the SW instruction in full:

\begin{verbatim}
'<main>' panicked at 'unhandled store32 into address 1f801010'
\end{verbatim}

The address is not part of the BIOS and therefore we don't support it
yet. We can figure out where we're trying to write by going back to
the memory map in table~\ref{tab:mmap}. We can see that we end up in
the "Hardware registers" range.

Looking at the specs we see that registers in this range are for
``memory control''. They're mainly used to set things like access
latencies to the various peripherals. We're going to hope we don't
need to emulate those very low level settings so we'll ignore the
writes to those registers for now.

\subsubsection{Expansion mapping}

There are two memory control registers we need to be careful about
however: registers \code{0x1f801000} and \code{0x1f801004} contain
the base address of the expansion 1 and 2 register maps. We could
emulate dynamic mappings but apparently on the Playstation they're
always at \code{0x1f000000} and \code{0x1f802000} respectively so
we're just going to hardcode those addresses and raise an error if the
BIOS or a game ever attempts to remap them to something else (which
hopefully shouldn't ever happen).

\begin{lstlisting}
impl Interconnect {
    //...

    /// Store 32bit word `val` into `addr`
    pub fn store32(&mut self, addr: u32, val: u32) {
        //...

        if let Some(offset) = map::MEM_CONTROL.contains(addr) {
            match offset {
                0 => // Expansion 1 base address
                    if val != 0x1f000000 {
                        panic!("Bad expansion 1 base address: 0x{:08x}", val);
                    },
                4 => // Expansion 2 base address
                    if val != 0x1f802000 {
                        panic!("Bad expansion 2 base address: 0x{:08x}", val);
                    },
                _ =>
                    println!("Unhandled write to MEM_CONTROL register"),
            }
            return;
        }

        panic!("unhandled store32 into address {:08x}", addr);
    }
}
\end{lstlisting}

And of course we need to declare the \code{MEM\_CONTROL} constant:

\begin{lstlisting}
/// Memory latency and expansion mapping
pub const MEM_CONTROL: Range = Range(0x1f801000, 36);
\end{lstlisting}

It's a bit hackish but at least the store will now go through.

Before we move on to the next instruction we need to address the
``subtle brokenness'' in our SW implementation I was talking about
earlier.

\subsection{Sign extension}

The reason our current ``Store word'' extension is broken is because
we're not handling the immediate value correctly. It should be
interpreted like a signed 16bit value in a
\href{https://en.wikipedia.org/wiki/Two%27s_complement}{two's complement}
representation.

In other words, if the immediate value of the SW was \code{0xffff}
it would give an offset of -1, not +65535.

\begin{table}[ht]
  \centering

  \begin{tabular}{ l | l | l }
    16bit value & 32bit ``unsigned'' extended value & decimal unsigned value \\
    \hline
    \code{0x0000} & \code{0x00000000} & 0     \\
    \code{0x0001} & \code{0x00000001} & 1     \\
    \code{0x01ad} & \code{0x000001ad} & 429   \\
    \code{0xffff} & \code{0x0000ffff} & 65535 \\
    \code{0x83c5} & \code{0x000083c5} & 33733 \\
    \hline
    \hline
    16bit value & 32bit sign-extended value & decimal signed value \\
    \hline
    \code{0x0000} & \code{0x00000000} & 0      \\
    \code{0x0001} & \code{0x00000001} & 1      \\
    \code{0x01ad} & \code{0x000001ad} & 429    \\
    \code{0xffff} & \code{0xffffffff} & -1     \\
    \code{0x83c5} & \code{0xffff83c5} & -31803 \\
  \end{tabular}

  \caption{16 to 32bit conversion: with and without sign extension}
  \label{tab:signextend}
\end{table}

In order to support this we don't need to add any branching, we just
need to \href{https://en.wikipedia.org/wiki/Sign_extension}{sign
  extend} the immediate value. It means that we increase the width of
the 16bit value to 32bit but instead of padding with zeroes we pad
with the original MSB (which is sometimes called the
\href{https://en.wikipedia.org/wiki/Sign_bit}{sign bit}). This way the
signed value remains the same. See table~\ref{tab:signextend} for some
examples.

You can see that for values where the sign bit is not set if we simply
pad the 16 high bits with 0s we get the same result in both signed and
unsigned extension. However for values with the MSB set to 1 we have a
big difference. So when we extend values it's important to know if
we're dealing with signed or unsigned quantities. We'll have the same
problem with rightwise bitshifts: if we're shifting signed quantities
we have to pad with the sign bit.

It might sounds complicated but it's very straightforward to implement
with most programming languages, for instance in C, C++ and Rust
simply casting from a 16bit signed integer to a 32bit integer makes
the compiler sign-extend the value. If it didn't casting a 16bit
variable containing -1 into a 32bit variable would have the final
value be 65535 which is obviously not what we want.

We can't guess which instructions use signed or unsigned immediate
values, it's described in the MIPS instruction set. For instance our
ORI instruction correctly uses an unsigned immediate value.

The nice thing with two's complement representation is that while we
need to think about the signedness of the value when bitshifting and
widening it doesn't matter for most arithmetic operations.

For instance the 16 bit addition 0x01ad + 0x84e0 gives the same result
whether the operands are signed or not: 0x01ad is 429, 0x84e0 is
either 34016 if it's unsigned or -31520 if it's a two's complement
signed value. 429 + 34016 is 34445 or 0x868d in hexadecimal. 429 -
31520 is -31091 or 0x868d in 16bit two's complement hexadecimal.

You can see that doing the calculation with signed or unsigned
quantities doesn't matter: we end up with the same binary pattern.

Therefore we just need to care about the sign when widening the
immediate from 16 to 32 bits and then we can proceed with our usual
"unsigned" addition and we'll get the correct result whether the
offset is negative or positive:

\begin{lstlisting}
impl Instruction {
    // ...

    /// Return immediate value in bits [16:0] as a sign-extended 32bit
    /// value
    fn imm_se(self) -> u32 {
        let Instruction(op) = self;

        let v = (op & 0xffff) as i16;

        v as u32
    }
}
\end{lstlisting}

Note the order of the casts from \code{u32} to \code{i16} back to
\code{u32}. They might look useless but that's what's forcing the
compiler to generate instructions to sign-extend \code{v}.

\subsection{SW instruction}

We can now use this function to fix \code{op\_sw}, we just have to
replace \code{instruction.imm()} with the new sign-extending
\code{instruction.imm\_se()}:

\begin{lstlisting}
impl Cpu {
    // ...

    /// Store Word
    fn op_sw(&mut self, instruction: Instruction) {
        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);
        let v    = self.reg(t);

        self.store32(addr, v);
    }
}
\end{lstlisting}

This version of SW should work correctly even if the offset \code{i}
is negative.

\subsection{SLL instruction}

The next instruction is simply \code{0x00000000}. Looks strange but
it's perfectly valid. As always we start by reading the bits [31:26]
which obviously gives us \code{0b000000}. This value however can
introduce a number of instructions, to figure out which one we need to
read bits [5:0] which are again full zeroes. By looking at the
instruction set reference we see that these value correspond to a
``shift left logical'' (SLL). If we decode the entire instruction we
end up with:

\begin{lstlisting}[language=assembly]
sll $zero, $zero, 0
\end{lstlisting}

Obviously this instruction does absolutely nothing since it stores the
result in \$zero. This instruction is just the preferred way to encode
a \href{https://en.wikipedia.org/wiki/NOP}{NOP}\footnote{MIPS
  assemblers actually feature a \code{nop} pseudo-instruction that
  generates this \mbox{\code{sll \$zero, \$zero, 0}} instruction.}.
There are many instruction in the MIPS architecture that behave like
NOPs, for instance using the opcodes we've already encountered we can
craft several other NOPs:

\begin{lstlisting}[language=assembly]
lui $zero, 0
ori $zero, $zero, 0
ori $zero, $4, 1234
\end{lstlisting}

And there are many others since almost anything targeting \$zero is a
NOP\footnote{One exception would be memory loads which can have side
  effects even if the value is discarded in \$zero.}. I think the SLL
version is preferred simply because it has this noticeable encoding of
being all 0s.

In this case I can only assume that the NOP is used as a delay,
probably waiting for the previous SW instructions to take effect but
I'm not entirely sure why it's needed.

In our emulator we won't special-case this particular instruction, we
can just implement the generic SLL instruction in full. Since NOPs are
pretty common it might make some sense to special-case them but we'll
need to benchmark it to make sure the cost of the test won't be
greater than computing a useless shift and storing it in \$zero.

Let's start by implementing the accessors (the shift immediate is only
5bits since it wouldn't make sense to shift by more than 31 places and
the rest of the low bits is taken by the ``subfunction'' part of the
instruction):

\begin{lstlisting}
impl Instruction {
    // ...

    /// Return register index in bits [15:11]
    fn d(self) -> u32 {
        let Instruction(op) = self;

        (op >> 11) & 0x1f
    }

    /// Return bits [5:0] of the instruction
    fn subfunction(self) -> u32 {
        let Instruction(op) = self;

        op & 0x3f
    }

    /// Shift Immediate values are stored in bits [10:6]
    fn shift(self) -> u32 {
        let Instruction(op) = self;

        (op >> 6) & 0x1f
    }
}
\end{lstlisting}

Now that we have our fancy getters ready to parse the instruction we
can implement the opcode itself:

\begin{lstlisting}
impl Cpu {
    // ...

    fn decode_and_execute(&mut self, instruction: Instruction) {
        match instruction.function() {
            0b000000 => match instruction.subfunction() {
                0b000000 => self.op_sll(instruction),
                _        => panic!("Unhandled instruction {:08x}",
                                   instruction.0),
            },
            0b001111 => self.op_lui(instruction),
            0b001101 => self.op_ori(instruction),
            0b101011 => self.op_sw(instruction),
            _        => panic!("Unhandled instruction {:08x}",
                               instruction.0),
        }
    }

    /// Shift Left Logical
    fn op_sll(&mut self, instruction: Instruction) {
        let i = instruction.shift();
        let t = instruction.t();
        let d = instruction.d();

        let v = self.reg(t) << i;

        self.set_reg(d, v);
    }
}
\end{lstlisting}

Obviously in this case it won't do anything since it's a NOP but it
should work correctly when we encounter a ``real'' SLL instruction.

\subsection{ADDIU instruction}

After that we encounter the instruction ``0x24080b88'' which is the
``Add Immediate Unsigned'' opcode. The name is completely misleading: it
seems to say that the immediate value is treated as unsigned (i.e. not
zero-extended instead of sign-extended) but it's not the case. The
only difference between ADDIU and ADDI (``Add Immediate'') is that
the latter generates an exception on overflow while the former simply
truncates the result. How they got to ``unsigned'' from that I have no
idea...

Knowing that it's easy to implement it in our emulator\footnote{I'll
  skip the code in \code{decode\_and\_execute} from now on, I'm sure
  you can figure it out by yourself\dots{}}:

\begin{lstlisting}
impl Cpu {
    // ...

    /// Add Immediate Unsigned
    fn op_addiu(&mut self, instruction: Instruction) {
        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let v = self.reg(s).wrapping_add(i);

        self.set_reg(t, v);
    }
}
\end{lstlisting}

If you decode the instruction in full you should end up with:

\begin{lstlisting}[language=assembly]
addiu $8, $zero, 0xb88
\end{lstlisting}

You can see an other use of the \$zero register: this time with the
ADDIU opcode it sets \$8 to the immediate value 0xb88. It saves having
a dedicated ``Load immediate'' opcode.

\subsection{RAM configuration register}

This value of \code{0x00000b88} is then stored at address
\code{0x1f801060}.

This register is called \code{RAM\_SIZE} in the
\href{problemkaputt.de/psx-spx.htm#memorycontrol}{NoCash specs}. The
exact purpose of this register remains partially unknown but it seems
to be configuring the memory controller. I assume that this controller
is capable of handling various amounts of RAM for instance and this
register lets the BIOS load the particular configuration needed by the
Playstation hardware.

At any rate, since we're trying to emulate the Playstation and not
some generic MIPS computer we probably don't have to handle this
register in any specific way so it's hopefully safe to ignore it. I
just add a new mapping entry, ignore the store at this address and
move along:

\begin{lstlisting}
/// Register that has something to do with RAM configuration,
/// configured by the BIOS
pub const RAM_SIZE: Range = Range(0x1f801060, 4);
\end{lstlisting}

After this instruction we get a few NOPs. I suppose that the ram size
configuration takes a few cycle to take effect and the BIOS delays a
bit before continuing.

\subsection{J instruction}

The next instruction is \code{0x0bf00054} which is a jump
instruction (J). This function is used to change the value of the PC
and have the CPU execution pipeline jump to some other location in
memory.

Jump behaves like a \emph{goto}: it sets the PC to the immediate value
contained in the instruction. Since the instruction is 32bit wide and
the instruction set uses 6bits to encode the opcode it can only
specify 26bits of the `PC` at once.

To make the most of those 26bits the target address is shifted two
places to the right. It's not a problem because instructions must be
aligned to a 32bit boundary so the two LSBs of the PC \emph{always}
have to be zero. It means that the instruction really encodes 28bits
of the target address. The remaining 4 high bits are the PC's MSB and
remain untouched. In the case of our current instruction this makes
the target address \code{0xbfc00150}.

You can see that this instruction cannot jump \emph{anywhere} in RAM,
only to an address within the current 256MB of addressable memory. If
the CPU needs to jump further away\footnote{For instance to an other
  region as we'll see later.} it'll have to use an other instruction
like JR which takes a full 32bit register containing the destination
address. But we'll see that soon enough.

First we need to add an accessor for the 26bit immediate field:

\begin{lstlisting}
impl Instruction {
    // ...

    /// Jump target stored in bits [25:0]
    fn imm_jump(self) -> u32 {
        let Instruction(op) = self;

        op & 0x3ffffff
    }
}
\end{lstlisting}

Now we can implement the instruction itself:

\begin{lstlisting}
impl Cpu {
    // ...

    /// Jump
    fn op_j(&mut self, instruction: Instruction) {
        let i = instruction.imm_jump();

        self.pc = (self.pc & 0xf0000000) | (i << 2);
    }
}
\end{lstlisting}

Looks simple enough but unfortunately it's broken. Why you ask?

\subsection{Branch delay slots}
\label{sec:bds}

The reason our implementation of ``jump'' doesn't work properly is
because one of the simplifying assumptions we made when we started
implementing the CPU does not hold in this case.

Remember when I said that the CPU fetches and execute an instruction
at each cycle, increments the PC and repeats? Well it's a bit more
complicated than that.

The MIPS architecture is
\href{https://en.wikipedia.org/wiki/Classic_RISC_pipeline}{pipelined}
It means that in order to increase the throughput of the processor it
splits its execution logic across several stages.

While one stage is busy decoding an instruction the instruction fetch
stage could already be loading the next one. It works like an assembly
line.

When the code executes linearly (i.e. without jumps or branches)
there's no problem: while the CPU decodes the instruction at PC the
instruction fetch stage can start loading the value at PC + 4.

But if the instruction being decoded is a jump or a branch things get
messy. The instruction fetch stage cannot know that the previous
instruction is supposed to change the execution path. When the
instruction reaches the execution stage the value of PC gets updated,
but it's too late a spurious instruction has been fetched into the
pipeline already.

So there you are, with an unwanted instruction in your pipeline. What
do you do?

Some architectures opt for flushing the pipeline in those cases. You
restart from the correct address. Of course that's a costly operation:
your CPU has to wait for the fresh instructions to make it all the way
through the pipeline before getting executed. Many modern
architectures do that and that's why they generally include complex
\href{https://en.wikipedia.org/wiki/Branch_predictor}{branch
  predictors} which do their best to guess if a branch is about to be
taken. If they make a bad prediction the pipeline has to be
flushed. That's one of the main reasons branches are considered
expensive (and why I always overwrite \code{regs[0]} in
\code{set\_reg} instead of checking if the register was 0).

MIPS however doesn't do that. It doesn't bother wasting time flushing
the pipeline, it just ignore the issues and run the code anyway. What
this means is that the first instruction right \emph{after} a branch
always gets executed \emph{before} the branch is taken,
\emph{unconditionaly}. This instruction is said to be in the
\href{https://en.wikipedia.org/wiki/Delay_slot}{branch delay slot}

Consider the following assembly\footnote{I'm assuming that
  the assembler is not asked to reorder the instructions. To get this
  behaviour you have to use ``\code{.set noreorder}'' with the GNU
  assembler.}:

\begin{lstlisting}[language=assembly]
j   foo
lui $a0, 0xf00
\end{lstlisting}

The LUI instruction gets executed \emph{before} the code jumps to
\code{foo}. When the function is entered \$a0 will be equal to
\code{0x0f000000}.

Fortunately it's pretty easy to emulate this behaviour: we just have
to do the same thing the processor does and load the next instruction
before we execute the current one:

\begin{lstlisting}
/// CPU state
pub struct Cpu {
    /// The program counter register
    pc: u32,
    /// Next instruction to be executed, used to simulate the branch
    /// delay slot
    next_instruction: Instruction,

    // ...
}

impl Cpu {

    pub fn new(inter: Interconnect) -> Cpu {
        // ...

        Cpu {
            // PC reset value at the beginning of the BIOS
            pc: 0xbfc00000,
	    // ...
            next_instruction: Instruction(0x0), // NOP
        }
    }

    pub fn run_next_instruction(&mut self) {
        let pc = self.pc;

        // Use previously loaded instruction
        let instruction = self.next_instruction;

        // Fetch instruction at PC
        self.next_instruction = Instruction(self.load32(pc));

        // Increment PC to point to the next instruction. All
        // instructions are 32bit long.
        self.pc = pc + 4;

        self.decode_and_execute(instruction);
    }

    // ...
}
\end{lstlisting}

And now our jumps should behave correctly.

\subsection{OR instruction}

After the jump there's a sequence of LUI/ORI/SW used to store a bunch
of values in the \code{SYS\_CONTROL} registers that we chose to
ignore. We then stumbble upon a new instruction: \code{0x00000825}
which encodes a \emph{bitwise or} operation:

\begin{lstlisting}[language=assembly]
or $1, $zero, $zero
\end{lstlisting}

Unlike ORI which used an immediate value as a 2nd operand this one
takes two register and stores the result in a third one. We can see
that in this case the two source registers are \$zero so it just
clears \$1. The implementation is fairly straightforward:

\begin{lstlisting}
impl Cpu {
    // ...

    /// Bitwise Or
    fn op_or(&mut self, instruction: Instruction) {
        let d = instruction.d();
        let s = instruction.s();
        let t = instruction.t();

        let v = self.reg(s) | self.reg(t);

        self.set_reg(d, v);
    }
}
\end{lstlisting}

The next few instructions use OR to set \emph{all} the general purpose
registers to 0.

\subsection{Type safety in the register interface}

I've decided to make a modification to our Instruction interface:
right now the helper methods in the \code{Instruction} return
register indexes as \code{u32}. The same type as the values
contained in the registers. Therefore the compiler won't warn us if we
mess up and use a register index instead of a register value:

\begin{lstlisting}
impl Cpu {
    // ...

    /// Bitwise Or
    fn op_or(&mut self, instruction: Instruction) {
        let d = instruction.d();
        let s = instruction.s();
        let t = instruction.t();

        let v = s | self.reg(t); // Oops...

        self.set_reg(d, v);
    }
}
\end{lstlisting}

This code is broken: instead of OR-ing the value of the register
number \code{s} it ORs the index \code{s} itself. It's meaningless
and obviously wrong and yet it builds without any error.

Fortunately with a small modification in our code we can have the
compiler reject such code by wrapping register indexes in a new type
incompatible with \code{u32}:

\begin{lstlisting}
struct RegisterIndex(u32);
\end{lstlisting}

Note that this is not like a \code{typedef} in C or C++:
\code{typedef} just creates an alias which remains compatible
(i.e. interchangeable) with the original type. The equivalent in C
would be to wrap the \code{u32} in a \code{struct} or something like that.

Then we just have to update our helpers as well as the
\code{Cpu::reg} and \code{Cpu::set\_reg} methods to use a
\code{RegisterIndex} instead of a plain \code{u32}.

With this modification the compiler will reject the broken
\code{op\_or} implementation above:

\begin{verbatim}
Binary operation | cannot be applied to type cpu::RegisterIndex:
     let v = s | self.reg(t);
\end{verbatim}

Hurray for type safety!


\subsection{CACHE\_CONTROL register}

The BIOS then wants to write \code{0x00000804} to
\code{0xfffe0130}. This address is used for cache control. Since we
won't implement the caches yet we can just add a log message and
ignore this register for the moment:

\begin{lstlisting}
/// Cache control register
pub const CACHE_CONTROL: Range = Range(0xfffe0130, 4);
\end{lstlisting}

\subsection{The coprocessors}

The next unhandled instruction, \code{0x408c6000}, involves one of
the R3000 CPU coprocessors.

Coprocessors are pieces of hardware which live alongside the CPU and
are accessed through dedicated instructions (instead of memory mapped
I/O like external peripherals). They are used to complement and extend
the capabilities of the processor. They each have their own set of
registers.

The MIPS R3000 CPU can support up to 4 coprocessors:

\begin{itemize}
\item The coprocessor 0 (cop0) is mandated by the MIPS architecture:
  it's used for exception handling. Exceptions are things like
  hardware interrupts and traps (divisions by zero, integer overflows,
  system calls etc...). We'll study them in greater details when we'll
  implement them.

\item The coprocessor 1 (cop1) is optional: when available it's used for
  floating point arithmetic. You might expect that a videogame console
  would benefit greatly from having hardware accelerated floating point
  and yet cop1 is not implemented on the playstation! Instead we have
  the coprocessor 2.

\item The coprocessor 2 (cop2) is, as far as I know, custom made for
  the Playstation. At least I can't find any reference to it outside
  of the Playstation hardware. It's called the "Geometry
  Transformation Engine", or GTE for short. It implements many
  instructions dealing with 3D transforms like perspective
  transformations, vector and matrix multiplications, color
  manipulation etc... It's basically the first half of the rendering
  pipeline, the second half being the GPU (but that one is a memory
  mapped peripheral, not a coprocessor).

\item The coprocessor 3 (cop3) is not implemented on the Playstation.
\end{itemize}

Hopefully we shouldn't have to mess with the GTE until we start
encountering 3D code.

\subsection{MTC0 instruction}

Back to the \code{0x408c6000} instruction: the opcode (bits [31:26])
is equal to \code{0b010000} which means that it's an instruction for
the coprocessor 0. The generic format is \code{0b0100}\emph{nn} where
\emph{nn} is the coprocessor number.

\begin{lstlisting}
impl Cpu {
    //...

    fn decode_and_execute(&mut self, instruction: Instruction) {
        match instruction.function() {
	    //...
            0b010000 => self.op_cop0(instruction),
            _        => panic!("Unhandled instruction {}",
                               instruction),
        }
    }

    /// Coprocessor 0 opcode
    fn op_cop0(&mut self, instruction: Instruction) {
        match instruction.cop_opcode() {
            0b00100 => self.op_mtc0(instruction),
            _       => panic!("unhandled cop0 instruction {}",
                              instruction)
        }
    }
}
\end{lstlisting}

\code{Instruction::cop\_opcode} returns the same bit range as
\code{Instruction::s}, however it returns it as a plain \code{u32}
instead of a \code{RegisterIndex} (since it's not a register in this
case). You see that the current coprocessor opcode \code{0b00100} means
MTC0 or ``move to coprocessor 0''. This instruction takes two
parameters: the source register index (one of the CPU's general
registers) and the target register (one of the coprocessor's
register). Those parameters are respectively in bits [20:16] and
[15:11] of the instruction.

In our current instruciton both of those parameters are equal to 12 so
if we decode the instruction in full it gives\footnote{This is
  actually pseudo-assembly for the sake of clarity. The correct GNU
  assembler syntax would be \mbox{\code{mtc0 \$12, \$12}} but it's a
bit too ambiguous for my taste.}:

\begin{lstlisting}[language=assembly]
mtc0 $12, $cop0_12
\end{lstlisting}

The coprocessor register \$cop0\_12 is very useful: it's called the
``status register'' or SR for short. Among other things it's used to
query and mask the exceptions and controlling the cache behaviour.

At this point the \$12 register contains \code{0x00010000} so this
MTC0 instruction sets bit 16 of SR which is the ``isolate cache''
bit. It makes all the following read and write target directly the
cache instead of going through it towards the main memory. We're
probably in the middle of the cache initialization sequence.

At any rate since we still haven't implemented anything cache-related
we'll just store the value of the SR in our \code{Cpu} struct and
move along:

\begin{lstlisting}
/// CPU state
pub struct Cpu {
    //...

    /// Cop0 register 12: Status Register
    sr: u32,
}

impl Cpu {
    //...

    pub fn new(inter: Interconnect) -> Cpu {
        //...

        Cpu {
	    //...
	    sr: 0,
        }
    }

    fn op_mtc0(&mut self, instruction: Instruction) {
        let cpu_r = instruction.t();
        let cop_r = instruction.d().0;

        let v = self.reg(cpu_r);

        match cop_r {
            12 => self.sr = v,
            n  => panic!("Unhandled cop0 register: {:08x}", n),
        }
    }
}
\end{lstlisting}

Setting the SR to 0 on reset might not be accurate but I doubt it
matters much.

Since the cache is supposed to be isolated all ``stores'' should end
up in the cache and never in the main memory. Even if we don't
implement the cache we don't want the BIOS to start writing at random
locations in main memory when it thinks it writes to the cache so we
can start by ignoring all writes when this isolation bit is set:

\begin{lstlisting}
impl Cpu {
    //...

    /// Store Word
    fn op_sw(&mut self, instruction: Instruction) {

        if self.sr & 0x10000 != 0 {
            // Cache is isolated, ignore write
            println!("ignoring store while cache is isolated");
            return;
        }

	//...
    }
}
\end{lstlisting}

\subsection{BNE instruction}

We now encounter the instruction \code{0x154bfff7}. It encodes a BNE
or ``branch if not equal'' instruction. The difference between jumps
and branches is that branches are \emph{conditional} and they use
\emph{relative offsets}.

The immediate value is sign extended (in order to allow for negative
offsets) and multiplied by 4 (as always, the PC must be aligned to
32bits at all times). Therefore this instruction decodes to:

\begin{lstlisting}[language=assembly]
bne $10, $11, -36
\end{lstlisting}

In other words the instruction will compare the values in \$10 and
\$11 and \emph{if} they're unequal it'll subtract 36 from the
PC. If the values are equal it'll do absolutely nothing.

Like jumps, branches have a delay slot\footnote{It is called a
  \emph{branch} delay slot after all\dots}. Fortunately our
implementation in section~\ref{sec:bds} already takes care of that
without any more work.

I've decided to factor the ``branching'' code itself in a separate
function because we'll have to use the same logic in the other branch
instructions:

\begin{lstlisting}
impl Cpu {
    //...

    /// Branch to immediate value `offset`.
    fn branch(&mut self, offset: u32) {
        // Offset immediates are always shifted two places to the
        // right since `PC` addresses have to be aligned on 32bits at
        // all times.
        let offset = offset << 2;

        let mut pc = self.pc;

        pc = pc.wrapping_add(offset);

        // We need to compensate for the hardcoded
        // `pc.wrapping_add(4)` in `run_next_instruction`
        pc = pc.wrapping_sub(4);

        self.pc = pc;
    }

    /// Branch if Not Equal
    fn op_bne(&mut self, instruction: Instruction) {
        let i = instruction.imm_se();
        let s = instruction.s();
        let t = instruction.t();

        if self.reg(s) != self.reg(t) {
            self.branch(i);
        }
    }
}
\end{lstlisting}

Notice the \code{wrapping\_sub(4)} to compensate for our
\code{pc.wrapping\_add(4)} in
\code{run\_next\_instruction}. Without it we'd branch one
instruction too far.

\subsection{ADDI instruction}

Before we even reach the target of the branch we stumble upon
unhandled instruction \code{0x214a0080}. This one is an ADDI which
behaves exactly like the ADDIU instruction we've already implemented
except that it generates an exception if the addition overflows.

The instruction decodes to:
\begin{lstlisting}[language=assembly]
addi $10, $10, 128
\end{lstlisting}

Since this operation checks for signed overflow I'll cast the operands
to \code{i32} before using the \code{checked\_add} provided by
rust's standard library\footnote{If you're implementing this in C or
  C++ and need to check for signed overflow yourself you'll find
  plenty of examples online. Welcome to the 1970s. Be careful with
  your implementation though because signed integer overflow is
  undefined behaviour in C.}. For now I just panic if we encounter an
  overflow, we'll change that when we actually implement exceptions:

\begin{lstlisting}
impl Cpu {
    //...

    /// Add Immediate Unsigned and check for overflow
    fn op_addi(&mut self, instruction: Instruction) {
        let i = instruction.imm_se() as i32;
        let t = instruction.t();
        let s = instruction.s();

        let s = self.reg(s) as i32;

        let v = match s.checked_add(i) {
            Some(v) => v as u32,
            None    => panic!("ADDI overflow"),
        };

        self.set_reg(t, v);
    }
}
\end{lstlisting}

The cast to \code{i32} is important because something like
\code{0x4 + 0xffffffff} is an overflow in 32bit unsigned
arithmetics. If the operands are signed however it's simply 4 + -1 and
that's obviously perfectly fine. The actual result of the operation
would be the same (\code{0x00000003}) but since ADDI generates an
exception on overflow the difference in behaviour is critical.

\subsection{Memory loads}

The next unhandled instruction, \code{0x8d090000} is LW or ``load
word''. It decodes to:

\begin{lstlisting}[language=assembly]
lw $9, 0($8)
\end{lstlisting}

We can reuse the \code{load32} method to fetch the data from memory:

\begin{lstlisting}
impl Cpu {
    //...

    /// Load Word
    fn op_lw(&mut self, instruction: Instruction) {

        if self.sr & 0x10000 != 0 {
            // Cache is isolated, ignore write
            println!("Ignoring load while cache is isolated");
            return;
        }

        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);

        let v = self.load32(addr);

        self.set_reg(t, v);
    }
}
\end{lstlisting}

There's a subtle problem with this implementation however.

\subsection{Load delay slots}

Sounds familiar? It's our friend the pipeline messing with us once
again. What happens is that the load instructions attempts to read
from the memory, but that takes time. At least, it takes more than a
single cycle.

On the R3000 CPU it creates ``load delay slots'': when you load a
value from memory the CPU will execute the next instruction
\emph{before} the value is fetched into the target
register\footnote{This behaviour is part of the MIPS~I
  architecture. Later revisions (starting with MIPS~II) don't
  have load delay slots, only branch delay slots.}.

Consider this sequence of instructions:

\begin{lstlisting}[language=assembly]
lw   $1, 0($zero)  /* Load $1 with the value at address 0 */
move $2, $1        /* Move $1 in $2 */
move $3, $1        /* Move $1 in $3 */
\end{lstlisting}

The first MOVE instruction\footnote{As I mentioned earlier MOVE is
  actually a pseudo-instruction that the assembler will expand into an
  \code{addu \$<\emph{target}>, \$<\emph{source}>, \$zero}.} is in
the load delay slot of the previous LW. That means that at that point
the register \$1 does not yet contain the value loaded into it. So
after these two instructions \$2 contains the value of \$1
\emph{before} the load. The 2nd MOVE however takes place after the
load delay slot so \$3 will contain the final, post-load value of \$1.

But it gets worse. Consider the value of \$1 after these two
instructions:

\begin{lstlisting}[language=assembly]
lw    $1, 0($zero)  /* Load $1 with the value at address 0 */
addiu $1, $zero, 42 /* Put 42 in $1 */
\end{lstlisting}

We first use LW to load something in \$1 and then, while the load
takes place, we change the value of \$1 with an ADDIU instruction. Who
wins?

You might think that since the LW finishes after the load delay slot
its fetched value will override the one set by the ADDIU. It turns out
that it's not the case however: after those two instructions \$1 will
contain 42, no matter what the LW fetched.

It's a bit of a bad news for us emulator writers. It means we can't
execute the load before the delay slot because the instruction must
see the previous value of the loaded register (otherwise the first
example code above won't work) and we can't just execute it afterwards
because it would make the load take the priority over the delay slot
(thus breaking our 2nd example).

One way to see it is that the loaded value ends up in the target
register \emph{after} the next instruction has fetched the input
register values but \emph{before} the next instruction updates the
target register values. In our first example \$1 is an input register
to both MOVEs while in the 2nd it's the output (destination) register
of the ADDIU.

We could implement it exactly that way by splitting each instruction
in two:
\begin{itemize}
\item The first part would take the pre-load register values, compute
  the result (adding \$zero and 10 in the 2nd example example above),
\item Then it would execute any pending load,
\item Finally it would store the result of the computation in the
  target register (\$1 in the ADDIU). That way the ADDIU will write
  last.
\end{itemize}

I don't really like this solution however because we'll have to handle
load delays explicitly in all instructions which seems inelegant and
error-prone.

Instead I'm going to use two sets of general purpose registers: one
will be the \emph{input} set and the other the \emph{output} set. Each
instruction will read its input values from the former set and will
write to the latter. Once the instruction is finished we copy the
output set into the input set for the next instruction.

This way we can update the output register set with the load value
\emph{before} we execute the instruction and it will still see the old
value from the \emph{input} set. And if the instruction writes to the
same register it will overwrite the value in the \emph{output} set.

Hopefully it should be clearer in code. First let's add a 2nd set of
registers and a (register, value) tuple containing the pending load:

\begin{lstlisting}
/// CPU state
pub struct Cpu {
    //...

    /// 2nd set of registers used to emulate the load delay slot
    /// accurately. They contain the output of the current
    /// instruction.
    out_regs: [u32; 32],
    /// Load initiated by the current instruction
    load: (RegisterIndex, u32),
}

impl Cpu {

    pub fn new(inter: Interconnect) -> Cpu {
        //...

        Cpu {
            //...
	    out_regs: regs,
            load: (RegisterIndex(0), 0),
        }
    }

    //...
}
\end{lstlisting}

If no load is pending we can just target \$zero since it doesn't do
anything.

Now we can update the \code{set\_reg} method to target the
\emph{output} register set:

\begin{lstlisting}
impl Cpu {
    //...

    fn set_reg(&mut self, index: RegisterIndex, val: u32) {
        self.out_regs[index.0 as usize] = val;

        // Make sure R0 is always 0
        self.out_regs[0] = 0;
    }
}
\end{lstlisting}

Since all our instructions so far use this helper method to update the
register values we won't have to modify their code at all.

The next step is to update \code{run\_next\_instruction} to handle
pending loads and copying the output registers between every
instructions:

\begin{lstlisting}
impl Cpu {
    //...

    pub fn run_next_instruction(&mut self) {
        //...

        // Execute the pending load (if any, otherwise it will load
        // $zero which is a NOP). `set_reg` works only on
        // `out_regs` so this operation won't be visible by
        // the next instruction.
        let (reg, val) = self.load;
        self.set_reg(reg, val);

        // We reset the load to target register 0 for the next
        // instruction
        self.load = (RegisterIndex(0), 0);

        self.decode_and_execute(instruction);

        // Copy the output registers as input for the
        // next instruction
        self.regs = self.out_regs;
    }
}
\end{lstlisting}

You can see that we're copying 128 bytes worth of registers for each
instruction which might not be great performance-wise but at this
point I don't really care about that.

\subsection{LW instruction}

We can now write the correct, load-delay friendly implementation of
SW:

\begin{lstlisting}
impl Cpu {
    //...

    /// Load Word
    fn op_lw(&mut self, instruction: Instruction) {

        if self.sr & 0x10000 != 0 {
            // Cache is isolated, ignore write
            println!("Ignoring load while cache is isolated");
            return;
        }

        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);

        let v = self.load32(addr);

        // Put the load in the delay slot
        self.load = (t, v);
    }
}
\end{lstlisting}

\subsection{The RAM}

\label{sec:ram}

Unfortunately we can't test our brand new load delay slot just yet
because the current instruction attemps to load from an unhandled
address: \code{0xa0000000}. The memory map\ref{tab:mmap} tells us that
this is the first address in RAM.

Adding RAM support is straightforward: it's very similar to our BIOS
implementation except it boots up uninitialized and it's not
read-only:

\begin{lstlisting}
/// RAM
pub struct Ram {
    /// RAM buffer
    data: Vec<u8>
}

impl Ram {

    /// Instantiate main RAM with garbage values
    pub fn new() -> Ram {

        // Default RAM contents are garbage
        let data = vec![0xca, 2 * 1024 * 1024];

        Ram { data: data }
    }

    /// Fetch the 32bit little endian word at `offset`
    pub fn load32(&self, offset: u32) -> u32 {
        let offset = offset as usize;

        let b0 = self.data[offset + 0] as u32;
        let b1 = self.data[offset + 1] as u32;
        let b2 = self.data[offset + 2] as u32;
        let b3 = self.data[offset + 3] as u32;

        b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
    }

    /// Store the 32bit little endian word `val` into `offset`
    pub fn store32(&mut self, offset: u32, val: u32) {
        let offset = offset as usize;

        let b0 = val as u8;
        let b1 = (val >> 8) as u8;
        let b2 = (val >> 16) as u8;
        let b3 = (val >> 24) as u8;

        self.data[offset + 0] = b0;
        self.data[offset + 1] = b1;
        self.data[offset + 2] = b2;
        self.data[offset + 3] = b3;
    }
}
\end{lstlisting}

I arbitrarily chose \code{0xca} as the poison value on startup. It's pretty
strange that the BIOS attempts to fetch data from the RAM before
writing anything to it (and effectively reading garbage) but if you
look at the following instructions it repeatedly reads the same
address (the first word in RAM) and does nothing with it. I'm not sure
what this code does but it probably initializes something. Let's hope
it's not too important\dots{}

We can then plug our brand new RAM in the interconnect as usual:

\begin{lstlisting}
pub const RAM: Range = Range(0xa0000000, 2 * 1024 * 1024);
\end{lstlisting}

\subsection{The coprocessor 0 registers}

After that the BIOS wants to initialize the remaining cop0 registers
by loading \$zero into them with the MTC0 instruction.

Let's take the time to review those registers:

\begin{itemize}
\item \$cop0\_3 is BPC, used to generate a breakpoint exception when the
  PC takes the given value.

\item \$cop0\_5 is BDA, the data breakpoint. It's like BPC except it
  breaks when a certain address is accessed on a data load/store instead
  of a PC value.

\item \$cop0\_6: I couldn't find a lot of informations on this
  register or what it does, the consensus seems to be that it's
  basically useless.

\item \$cop0\_7 is DCIC, used to enable and disable the various
  hardware breakpoints.

\item \$cop0\_9 is BDAM, it's a bitmask applied when testing for BDA
  above. That way we could trigger on a range of address instead of a
  single one.

\item \$cop0\_11 is BPCM, like BDAM but for masking the BPC
  breakpoint.

\item \$cop0\_12 we've already encountered: it's SR, the status register.

\item \$cop0\_13 is CAUSE, which contains mostly read-only data
  describing the cause of an exception. Apparently only bits [9:8] are
  writable to force an exception.
\end{itemize}

You can see that most of those registers (except SR and CAUSE) deal
with hardware breakpoints. That's generally used for debugging so we
shouldn't need to emulate those for most games. It's probably safe to
ignore for now. You can see that the BIOS loads \$zero into all of
them which disables them.

For now we're just going to ignore write to these registers when the
value is 0. If at some point some game writes something else we'll
catch it and see what we need to implement:

\begin{lstlisting}
impl Cpu {
    //...

    /// Move To Coprocessor 0
    fn op_mtc0(&mut self, instruction: Instruction) {
        let cpu_r = instruction.t();
        let cop_r = instruction.d().0;

        let v = self.reg(cpu_r);

        match cop_r {
            3 | 5 | 6 | 7 | 9 | 11  => // Breakpoints registers
                if v != 0 {
                    panic!("Unhandled write to cop0r{}", cop_r)
                },
            12 => self.sr = v,
            13 => // Cause register
                if v != 0 {
                    panic!("Unhandled write to CAUSE register.")
                },
            _  => panic!("Unhandled cop0 register {}", cop_r),
        }
    }
}
\end{lstlisting}

\subsection{SLTU instruction}

After that we encounter the instruction \code{0x0043082b} which
encodes the ``set on less than unsigned''(STLU) opcode:

\begin{lstlisting}[language=assembly]
sltu $1, $2, $3
\end{lstlisting}

This instruction compares the value of two registers (\$2 and \$3 in
this case) and sets the value of a third one (\$1) to either 0 or 1
depending on the result of the ``less than'' comparison:

\begin{lstlisting}
impl Cpu {
    //...

    /// Set on Less Than Unsigned
    fn op_sltu(&mut self, instruction: Instruction) {
        let d = instruction.d();
        let s = instruction.s();
        let t = instruction.t();

        let v = self.reg(s) < self.reg(t);

        self.set_reg(d, v as u32);
    }
}
\end{lstlisting}

\subsection{ADDU instruction}

We then stumble upon the instruction \code{0x03a0f021} which encodes
an ``Add unsigned'' (ADDU) opcode:

\begin{lstlisting}[language=assembly]
addu $30, $29, $zero
\end{lstlisting}

You can see that with \$zero as the third operand it simply moves \$29
in \$30, so in this case it's really a MOVE instruction.

The instruction is implemented like ADDIU except that we add two
registers instead of a register and an immediate value:

\begin{lstlisting}
impl Cpu {
    //...

    /// Add Unsigned
    fn op_addu(&mut self, instruction: Instruction) {
        let s = instruction.s();
        let t = instruction.t();
        let d = instruction.d();

        let v = self.reg(s).wrapping_add(self.reg(t));

        self.set_reg(d, v);
    }
}
\end{lstlisting}

\subsection{Regions}

Our next problem is an unhandled access at address
\code{0x00000060}. If we look at the memory map\ref{tab:mmap} we see
  that it's the RAM. But we've already added the RAM in our
  interconnect in section~\ref{sec:ram}!

The problem is that currently we mapped the RAM at \code{0xa0000000},
in the KSEG1 region. But this time the BIOS attempts to access it
through an other region: KUSEG. We could add multiple mappings for
each peripheral in each region but that would be a waste of code and
performance.

Let's a closer look at how those regions are specified by the MIPS
architecture:

\begin{itemize}
\item KSEG0 starts at \code{0x80000000} and ends at
  \code{0x9fffffff}. This region is accessed through the caches but
  it's not mapped through the
  \href{https://en.wikipedia.org/wiki/Memory_management_unit}{MMU}. In
  order to get the physical address we just have to strip the MSB.

\item KSEG1 starts at \code{0xa0000000} and ends at
  \code{0xbfffffff}. This region is not cached or mapped through the
  MMU. In order to get the physical address we just have to strip the
  three MSBs.

\item KSEG2 starts at \code{0xc0000000} and ends at
  \code{0xffffffff}. This region is only accessed in kernel mode and
  is also cached and goes through the MMU.

\item KUSEG starts at \code{0x00000000} and ends at
  \code{0x7fffffff}. It's meant for user code and is both cached and
  goes through the MMU.
\end{itemize}

All that sounds rather complicated. Fortunately for us since we're
targeting the Playstation and not some generic MIPS architecture we'll
be able to make some simplifications:

\begin{itemize}
\item The Playstation hardware does not have a MMU and therefore no
  virtual memory. We won't have to deal with memory translation.

\item The Playstation CPU has 1KB of data cache and an other kilobyte
  of instruction cache. However the data cache is not used, instead
  its memory is mapped as the "scratpad" at a fixed location. In other
  word we don't need to implement the data cache.

\item As far as I can tell the Playstation software doesn't seem to
  use the kernel/user privilege separation and runs everything in
  kernel mode.
\end{itemize}

In other words the only time we'll need to worry about which region is
in use is when we'll implement the cache instruction and only for
KSEG1 since that's the only non-cached region.. For everything else it
doesn't matter through which region the peripherals are accessed.

In order to solve our issue of having multiple mappings at different
addresses for the same peripherals in different regions we want to
compute the unique physical address corresponding to a memory access
and map that through our interconnect code.

By the descriptions above you see that we should mask a different
number of bits depending on the region. Since KSEG2 doesn't share
anything with the other regions we won't touch the address here
(otherwise we would allow access to the RAM through KSEG2 for instance
and that wouldn't be accurate). In order to avoid branches we can use
a nice mask lookup table:

\begin{lstlisting}
/// Mask array used to strip the region bits of the address. The
/// mask is selected using the 3 MSBs of the address so each entry
/// effectively matches 512kB of the address space. KSEG2 is not
/// touched since it doesn't share anything with the other
/// regions.
const REGION_MASK: [u32; 8] = [
    // KUSEG: 2048MB
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    // KSEG0:  512MB
    0x7fffffff,
    // KSEG1:  512MB
    0x1fffffff,
    // KSEG2: 1024MB
    0xffffffff, 0xffffffff,
];

/// Mask a CPU address to remove the region bits.
pub fn mask_region(addr: u32) -> u32 {
    // Index address space in 512MB chunks
    let index = (addr >> 29) as usize;

    addr & REGION_MASK[index]
}
\end{lstlisting}

We can now use this \code{mask\_region} function in our interconnect's
load and store functions to convert any address coming from the CPU
into a unique physical address used to identify the target peripheral.

We also have to change all our current address map declarations to use
physical addresses:

\begin{lstlisting}
pub const RAM: Range = Range(0x00000000, 2 * 1024 * 1024);

pub const BIOS: Range = Range(0x1fc00000, 512 * 1024);

/// Unknown registers. The name comes from mednafen.
pub const SYS_CONTROL: Range = Range(0x1f801000, 36);

/// Register that has something to do with RAM configuration,
/// configured by the BIOS
pub const RAM_SIZE: Range = Range(0x1f801060, 4);

/// Cache control register. Full address since it's in KSEG2
pub const CACHE_CONTROL: Range = Range(0xfffe0130, 4);
\end{lstlisting}

\subsection{SH instruction}

The next unhandled instruction is \code{0xa5200180} which encodes
``store halfword'' (SH). It's used to write 16bits (a halfword) to the
memory:

\begin{lstlisting}[language=assembly]
sh $zero, 0x180($9)
\end{lstlisting}

The implementation is very similar to the ``store word'' instruction
except we truncate the register to 16bits and we'll have to implement
a new \code{store16} method on our interconnect\footnote{Having
  separate functions for various width should make the code easier to
  follow for now but it does create some code duplication, later on
  I'll use generics to factor them in a single function.}:

\begin{lstlisting}
impl Cpu {
    //...

    /// Store 16bit value into the memory
    fn store16(&mut self, addr: u32, val: u16) {
        self.inter.store16(addr, val);
    }

    /// Store Halfword
    fn op_sh(&mut self, instruction: Instruction) {

        if self.sr & 0x10000 != 0 {
            // Cache is isolated, ignore write
            println!("Ignoring store while cache is isolated");
            return;
        }

        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);
        let v    = self.reg(t);

        self.store16(addr, v as u16);
    }
}
\end{lstlisting}

And in the interconnect:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Store 16bit halfword `val` into `addr`
    pub fn store16(&mut self, addr: u32, val: u16) {

        if addr % 2 != 0 {
            panic!("Unaligned store16 address: {:08x}", addr);
        }

        panic!("unhandled store16 into address {:08x}", addr);
    }
}
\end{lstlisting}


I start with an empty function instead of copying the \code{store32}
code because different devices react differently when we change the
transaction width. Some will pad the value to 32bits with zeroes,
others may just set 16bits in the register and leave the others
untouched. For this reason I'll be conservative and add them only when
needed.

\subsection{SPU registers}

If we run that code we see that this \code{store16} attempts to store
0 at \code{0x1f801d80}. Looking at the memory map we see it's the
address of a sound processing unit~(SPU) hardware register. At that
point we don't really care for sound so we're going to ignore writes
to these addresses for the time being:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Store 16bit halfword `val` into `addr`
    pub fn store16(&mut self, addr: u32, _: u16) {

        if addr % 2 != 0 {
            panic!("Unaligned store16 address: {:08x}", addr);
        }

        let abs_addr = map::mask_region(addr);

        if let Some(offset) = map::SPU.contains(abs_addr) {
            println!("Unhandled write to SPU register {:x}", offset);
            return;
        }

        panic!("unhandled store16 into address {:08x}", addr);
    }
}

/// SPU registers
pub const SPU: Range = Range(0x1f801c00, 640);
\end{lstlisting}

\subsection{JAL instruction}

The next unhandled instruction should be \code{0x0ff00698} which is a
``jump and link'' (JAL). It behaves like the regular jump instruction
except that it also stores the return address in \$ra (\$31):

\begin{lstlisting}[language=assembly]
jal 0xfc01a60
\end{lstlisting}

Using this instruction it's easy to implement function calls: the
instruction is called with JAL and can return to the caller by jumping
to the value in \$ra. Then the control returns to the calling
function. The \$ra register is the \emph{link} between the caller and
the callee.

We can reuse the regular J opcode implementation and simply add the
code to store the return value in \$31:

\begin{lstlisting}
impl Cpu {
    //...

    /// Jump And Link
    fn op_jal(&mut self, instruction: Instruction) {
        let ra = self.pc;

        // Store return address in $31 ($ra)
        self.set_reg(RegisterIndex(31), ra);

        self.op_j(instruction);
    }
}
\end{lstlisting}

\subsection{ANDI instruction}

We continue with instruction \code{0x308400ff} which is a ``bitwise
and immediate'' (ANDI):

\begin{lstlisting}[language=assembly]
andi $4, $4, 0xff
\end{lstlisting}

We can simply copy the implementation of ORI and replace the \code{|}
with an \code{\&}:

\begin{lstlisting}
impl Cpu {
    //...

    /// Bitwise And Immediate
    fn op_andi(&mut self, instruction: Instruction) {
        let i = instruction.imm();
        let t = instruction.t();
        let s = instruction.s();

        let v = self.reg(s) & i;

        self.set_reg(t, v);
    }
}
\end{lstlisting}

\subsection{SB instruction}

After the word and halfword store instructions we now meet
\code{0xa1c42041} which is a ``store byte'' (SB) instruction. We have
to implement a third path for accessing the memory like we did for
\code{store32} and \code{store32}:

\begin{lstlisting}
impl Cpu {
    //...

    /// Store 16bit value into the memory
    fn store8(&mut self, addr: u32, val: u8) {
        self.inter.store8(addr, val);
    }

    /// Store Byte
    fn op_sb(&mut self, instruction: Instruction) {

        if self.sr & 0x10000 != 0 {
            // Cache is isolated, ignore write
            println!("Ignoring store while cache is isolated");
            return;
        }

        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);
        let v    = self.reg(t);

        self.store8(addr, v as u8);
    }
}
\end{lstlisting}

\subsection{Expansion 2}

The address being written to is \code{0x1f802041} which falls in the
expansion 2 memory map. As far as I can tell this expansion is only
used for debugging on development boards and doesn't do anything
useful on real hardware. Therefore we'll just ignore writes to this
expansion:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Store byte `val` into `addr`
    pub fn store8(&mut self, addr: u32, _: u8) {
        let abs_addr = map::mask_region(addr);

        if let Some(offset) = map::EXPANSION_2.contains(abs_addr) {
            println!("Unhandled write to expansion 2 register {:x}", offset);
            return;
        }

        panic!("unhandled store8 into address {:08x}", addr);
    }
}

/// Expansion region 2
pub const EXPANSION_2: Range = Range(0x1f802000, 66);
\end{lstlisting}

\subsection{JR instruction}

A few steps later we encounter \code{0x03e00008} which is the ``jump
register'' (JR) instruction. It simply sets the PC to the value stored
in one of the general purpose registers:

\begin{lstlisting}[language=assembly]
jr $31
\end{lstlisting}

Since JAL stores the return address in \$31 we can return from a
subroutine by calling \code{jr \$ra} which is exactly what the BIOS
is doing here.

\begin{lstlisting}
impl Cpu {
    //...

    /// Jump Register
    fn op_jr(&mut self, instruction: Instruction) {
        let s = instruction.s();

        self.pc = self.reg(s);
    }
}
\end{lstlisting}

\subsection{LB instruction}

The next unhandled instruction is \code{0x81efe288} which encodes
``load byte'' (LB). As you can guess it's like LW except that it only
loads 8bits from the memory\footnote{Note the use of a negative
  offset, if we hadn't implemented proper sign extension earlier this
  instruction would misbehave.}:

\begin{lstlisting}[language=assembly]
lb $15, -7544($15)
\end{lstlisting}

Since the general purpose registers are always 32bit LB only loads the
low 8bits of the register. The byte is treated like a signed value so
it's sign extended to the full 32bits. Of course like LW there's a
load delay of one instruction. We can implement it like
this\footnote{Note the cast from \code{u8} to \code{i8} and finally
  \code{u32} to force the sign extension.}:

\begin{lstlisting}
impl Cpu {
    //...

    /// Load 8bit value from the memory
    fn load8(&self, addr: u32) -> u8 {
        self.inter.load8(addr)
    }

    /// Load Byte (signed)
    fn op_lb(&mut self, instruction: Instruction) {

        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);

        // Cast as i8 to force sign extension
        let v = self.load8(addr) as i8;

        // Put the load in the delay slot
        self.load = (t, v as u32);
    }
}
\end{lstlisting}

Next is the \code{Interconnect} implementation. The current
instruction attempts to load from an address within the BIOS so we'll
add support for it:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Load byte at `addr`
    pub fn load8(&self, addr: u32) -> u8 {
        let abs_addr = map::mask_region(addr);

        if let Some(offset) = map::BIOS.contains(abs_addr) {
            return self.bios.load8(offset);
        }

        panic!("unhandled load8 at address {:08x}", addr);
    }
}
\end{lstlisting}

And the implementation of \code{load8} in the BIOS:

\begin{lstlisting}
impl Bios {
    //...

    /// Fetch byte at `offset`
    pub fn load8(&self, offset: u32) -> u8 {
        self.data[offset as usize]
    }
}
\end{lstlisting}

\subsection{BEQ instruction}

We then get a new branch instruction: \code{0x11e0000c} is ``branch if
equal'' (BEQ):

\begin{lstlisting}[language=assembly]
beq $15, $zero, +48
\end{lstlisting}

We can reuse the code of BNE by changing the condition:

\begin{lstlisting}
impl Cpu {
    //...

    /// Branch if Equal
    fn op_beq(&mut self, instruction: Instruction) {
        let i = instruction.imm_se();
        let s = instruction.s();
        let t = instruction.t();

        if self.reg(s) == self.reg(t) {
            self.branch(i);
        }
    }
}
\end{lstlisting}

\subsection{Expansion 1}

After that the BIOS attemps to read a byte at \code{0x1f000084}. This
is where the first expansion port is mapped. This expansion goes to
the parallel port on the back of the early Playstation models.

If you look at the byte read by the first LB instruction above you'll
see it's the first byte in a C-string: ``\textit{Licensed by Sony
  Computer Entertainment Inc}''. Apparently in order to detect and
validate the expansion the BIOS compares this hardcoded string with
the values stored starting at offset 0x84 in the expansion.

We don't really have any reason to implement an expansion at that
point so we'll return the default value when no expansion is
present. Looking at mednafen's source code it seems to be
full-ones\footnote{I'm actually not sure how to test that easily since
  I need to have an expansion plugged in the parallel connector to be
  able to run code on my console. Maybe I could start the code and
  unplug it but that doesn't sound too great\dots{} A better way
  would be to burn the test code on a CD and run it on a modchipped
  console.}:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Load byte at `addr`
    pub fn load8(&self, addr: u32) -> u8 {
        let abs_addr = map::mask_region(addr);

        if let Some(offset) = map::BIOS.contains(abs_addr) {
            return self.bios.load8(offset);
        }

        if let Some(_) = map::EXPANSION_1.contains(abs_addr) {
            // No expansion implemented
            return 0xff;
        }

        panic!("unhandled load8 at address {:08x}", addr);
    }
}
\end{lstlisting}

\subsection{RAM byte access}

Now the BIOS wants to store a byte to the RAM but we haven't
implemented that yet, let's fix that by implementing \code{store8} and
let's add \code{load8} while we're at it:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Store byte `val` into `addr`
    pub fn store8(&mut self, addr: u32, val: u8) {
        let abs_addr = map::mask_region(addr);

        if let Some(offset) = map::RAM.contains(abs_addr) {
            return self.ram.store8(offset, val);
        }

	//...
    }

    /// Load byte at `addr`
    pub fn load8(&self, addr: u32) -> u8 {
        let abs_addr = map::mask_region(addr);

        if let Some(offset) = map::RAM.contains(abs_addr) {
            return self.ram.load8(offset);
        }

        //....
    }
}
\end{lstlisting}

And then in the RAM implementation:

\begin{lstlisting}
impl Ram {
    //...

    /// Store the byte `val` into `offset`
    pub fn store8(&mut self, offset: u32, val: u8) {
        self.data[offset as usize] = val;
    }

    /// Fetch the byte at `offset`
    pub fn load8(&self, offset: u32) -> u8 {
        self.data[offset as usize]
    }
}
\end{lstlisting}

\subsection{MFC0 instruction}

We've already met MTC0, now we encounter the reciprocal instruction:
\code{0x40026000} encodes ``move from coprocessor 0''
(MFC0)\footnote{I'm using peudo-assembly again. The proper GNU
  assembler syntax would be \code{mfc0~\$2,~\$12}}:

\begin{lstlisting}[language=assembly]
mfc0 $2, $cop0_12
\end{lstlisting}

There's one important thing to note however: MFC instructions behave
like memory loads and have a delay slot before the value is finally
stored in the target register.

Fortunately we can simply re-use our load delay slots infrastructure:

\begin{lstlisting}
impl Cpu {
    //...

    /// Move From Coprocessor 0
    fn op_mfc0(&mut self, instruction: Instruction) {
        let cpu_r = instruction.t();
        let cop_r = instruction.d().0;

        let v = match cop_r {
            12 => self.sr,
            13 => // Cause register
                panic!("Unhandled read from CAUSE register"),
            _  =>
                panic!("Unhandled read from cop0r{}", cop_r),
        };

        self.load = (cpu_r, v)
    }
}
\end{lstlisting}

\subsection{AND instruction}

An other easy instruction follows a few cycles later:
\code{0x00412024} which is a ``bitwise and'' (AND):

\begin{lstlisting}[language=assembly]
and $4, $2, $1
\end{lstlisting}

We've already implemented OR so we can reuse the code, only changing
the operator:

\begin{lstlisting}
impl Cpu {
    //...

    /// Bitwise And
    fn op_and(&mut self, instruction: Instruction) {
        let d = instruction.d();
        let s = instruction.s();
        let t = instruction.t();

        let v = self.reg(s) & self.reg(t);

        self.set_reg(d, v);
    }
}
\end{lstlisting}

\subsection{ADD instruction}

We already implemented ADDIU, ADDI and ADDU. We finally encounter
``add'' (ADD) in instruction \code{0x01094020}:

\begin{lstlisting}[language=assembly]
add $8, $8, $9
\end{lstlisting}

It adds the value of two registers (like ADDU) but generates an
exception on signed overflow (like ADDI):

\begin{lstlisting}
impl Cpu {
    //...

    /// Add and generate an exception on overflow
    fn op_add(&mut self, instruction: Instruction) {
        let s = instruction.s();
        let t = instruction.t();
        let d = instruction.d();

        let s = self.reg(s) as i32;
        let t = self.reg(t) as i32;

        let v = match s.checked_add(t) {
            Some(v) => v as u32,
            None    => panic!("ADD overflow"),
        };

        self.set_reg(d, v);
    }
}
\end{lstlisting}

\subsection{Interrupt Control registers}

The BIOS then attempts to write 0 at address
\code{0x1f801074}. Looking at the memory map this is the ``Interrupt
Mask'' register.

This register is used to activate or ignore external
\href{https://en.wikipedia.org/wiki/Interrupt}{interrupt signals}
(things like blanking interrupts from the GPU, timers, controller and
memory card interrupts etc\dots{}).

Interrupts are a signal coming from the peripherals to the CPU to
notify it that a certain event occurred (a timer reached its target
value, a button was pressed on the controller etc\dots{}). This way
the CPU doesn't have to waste time
\href{https://en.wikipedia.org/wiki/Polling_%28computer_science%29}{polling}
  the status of the various peripherals, it can just wait for the
  interrupt notification.

Writing 0 to this register masks all interrupts so it seems that the
BIOS wants to make sure it won't get interrupted before proceeding
further.

There's an other interrupt control register right before that one at
\code{0x1f801070}. That one is called ``Interrupt Status'' and is used
to query the status of the various interrupts (active or not).

Since we don't have any peripheral yet it wouldn't make sense to
implement interrupts at that point, we're going to ignore writes to
these addresses for now\footnote{IRQ is a common abbreviation for
  ``Interrupt Request''.}:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Store 32bit word `val` into `addr`
    pub fn store32(&mut self, addr: u32, val: u32) {
        //...

        if let Some(offset) = map::IRQ_CONTROL.contains(abs_addr) {
            println!("IRQ control: {:x} <- {:08x}", offset, val);
            return;
        }

        panic!("unhandled store32 into address {:08x}", addr);
    }
}

/// Interrupt Control registers (status and mask)
pub const IRQ_CONTROL: Range = Range(0x1f801070, 8);
\end{lstlisting}

\subsection{BGTZ instruction}

The next unhandled instruction is \code{0x1ca00003} which is a
``branch if greater than zero'' (BGTZ):

\begin{lstlisting}[language=assembly]
bgtz $5, +12
\end{lstlisting}

It's similar to the BEQ and BNE we've already encountered but
instead of comparing two registers it compares a single general
purpose register to 0.

The comparison is done using signed integers. For unsigned integers
the test would only ever be false if the register contained 0 and we
can already test that with BNE:

\begin{lstlisting}[language=assembly]
bne $5, $zero, +12
\end{lstlisting}

So we have to be careful to cast to a signed integer before the
comparison in our implementation:

\begin{lstlisting}
impl Cpu {
    //...

    /// Branch if Greater Than Zero
    fn op_bgtz(&mut self, instruction: Instruction) {
        let i = instruction.imm_se();
        let s = instruction.s();

        let v = self.reg(s) as i32;

        if v > 0 {
            self.branch(i);
        }
    }
}
\end{lstlisting}

\subsection{BLEZ instruction}

A few step later we encounter the complementary instruction
\code{0x18a00005} which encodes ``branch if less than or equal to
zero'' (BLEZ):

\begin{lstlisting}[language=assembly]
blez $5, +20
\end{lstlisting}

It's the same thing as BGTZ with the opposite predicate:

\begin{lstlisting}
impl Cpu {
    //...

    /// Branch if Less than or Equal to Zero
    fn op_blez(&mut self, instruction: Instruction) {
        let i = instruction.imm_se();
        let s = instruction.s();

        let v = self.reg(s) as i32;

        if v <= 0 {
            self.branch(i);
        }
    }
}
\end{lstlisting}

\subsection{LBU instruction}

After that we meet instruction \code{0x90ae0000} which is a ``load
byte unsigned'' (LBU):

\begin{lstlisting}[language=assembly]
lbu $14, 0($5)
\end{lstlisting}

It's exactly like LB but without sign extension, the high 24 bits of
the target register are set to 0:

\begin{lstlisting}
impl Cpu {
    //...

    /// Load Byte Unsigned
    fn op_lbu(&mut self, instruction: Instruction) {

        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);

        let v = self.load8(addr);

        // Put the load in the delay slot
        self.load = (t, v as u32);
    }
}
\end{lstlisting}

\subsection{JALR instruction}

Then we encounter instruction \code{0x0100f809} which encodes a ``jump
and link register'' (JALR):

\begin{lstlisting}[language=assembly]
jalr $31, $8
\end{lstlisting}

It's implemented like JR except that it also stores the return address
in a general purpose register. Unlike JAL, JALR can store the return
address in any general purpose register, not just \$ra:

\begin{lstlisting}
impl Cpu {
    //...

    /// Jump And Link Register
    fn op_jalr(&mut self, instruction: Instruction) {
        let d = instruction.d();
        let s = instruction.s();

        let ra = self.pc;

        // Store return address in `d`
        self.set_reg(d, ra);

        self.pc = self.reg(s);
    }
}
\end{lstlisting}

\subsection{BLTZ, BLTZAL, BGEZ and BGEZAL instructions}

The next unhandled instruction, \code{0x04800003}, is a bit of a weird
one: the six MSBs are \code{0b000001} which can encode four different
instructions:

\begin{itemize}
\item ``branch if less than zero'' (BLTZ):

  \begin{lstlisting}[language=assembly]
bltz   $4, +12
  \end{lstlisting}

\item ``branch if less than zero and link'' (BLTZAL):

  \begin{lstlisting}[language=assembly]
bltzal $4, +12
  \end{lstlisting}

\item ``branch if greater than or equal to zero'' (BGEZ):
  \begin{lstlisting}[language=assembly]
bgez   $4, +12
  \end{lstlisting}


\item ``branch if greater than or equal to zero and link'' (BGEZAL):

  \begin{lstlisting}[language=assembly]
bgezal $4, +12
  \end{lstlisting}

\end{itemize}

In order to figure out what to do exactly we need to look at bits 16
and 20 in the instruction:

\begin{itemize}
\item If bit 16 is set then the instruction is BGEZ, otherwise it's
  BLTZ.

\item If bit 20 is set then the return address is linked in \$ra.
\end{itemize}

Here's how it can be implemented:

\begin{lstlisting}
impl Cpu {
    //...

    /// Various branch instructions: BGEZ, BLTZ, BGEZAL, BLTZAL.
    /// Bits 16 and 20 are used to figure out which one to use.
    fn op_bxx(&mut self, instruction: Instruction) {
        let i = instruction.imm_se();
        let s = instruction.s();

        let instruction = instruction.0;

        let is_bgez = (instruction >> 16) & 1;
        let is_link = (instruction >> 20) & 1 != 0;

        let v = self.reg(s) as i32;

        // Test "less than zero"
        let test = (v < 0) as u32;

        // If the test is "greater than or equal to zero" we need
        // to negate the comparison above since
        // ("a >= 0" <=> "!(a < 0)"). The xor takes care of that.
        let test = test ^ is_bgez;

        if test != 0 {
            if is_link {
                let ra = self.pc;

                // Store return address in R31
                self.set_reg(RegisterIndex(31), ra);
            }

            self.branch(i);
        }
    }
}
\end{lstlisting}

Instead of testing bit 16 directly I save a branch by xoring the value
of \code{test} (which is a boolean 0 or 1) with it.

\subsection{SLTI instruction}

We then encounter \code{0x28810010} which encodes instruction ``set if
less than immediate'' (SLTI):

\begin{lstlisting}[language=assembly]
slti $1, $4, 16
\end{lstlisting}

It works like SLTU except that it compares a register with an
immediate value (sign-extended) and the comparison is done using
signed arithmetics:

\begin{lstlisting}
impl Cpu {
    //...

    /// Set if Less Than Immediate (signed)
    fn op_slti(&mut self, instruction: Instruction) {
        let i = instruction.imm_se() as i32;
        let s = instruction.s();
        let t = instruction.t();

        let v = (self.reg(s) as i32) < i;

        self.set_reg(t, v as u32);
    }
}
\end{lstlisting}

\subsection{SUBU instruction}

The next unhandled instruction is \code{0x01c47023} which encodes
``substract unsigned'' (SUBU):

\begin{lstlisting}[language=assembly]
subu $14, $14, $4
\end{lstlisting}

The implementation is straightforward:

\begin{lstlisting}
impl Cpu {
    //...

    /// Substract Unsigned
    fn op_subu(&mut self, instruction: Instruction) {
        let s = instruction.s();
        let t = instruction.t();
        let d = instruction.d();

        let v = self.reg(s).wrapping_sub(self.reg(t));

        self.set_reg(d, v);
    }
}
\end{lstlisting}

\subsection{SRA instruction}

Next we meet instruction \code{0x00042603} which is ``shift right
arithmetic'' (SRA):

\begin{lstlisting}[language=assembly]
sra $4, $4, 24
\end{lstlisting}

There are two versions of the shift right instruction: arithmetic and
logical. The arithmetic version considers that the value is signed and
use the sign bit to fill the missing MSBs in the register after the
shift.

In Rust, C and C++ we can achieve the same behavior by casting the
register value to a signed integer before doing the shift:

\begin{lstlisting}
impl Cpu {
    //...

    /// Shift Right Arithmetic
    fn op_sra(&mut self, instruction: Instruction) {
        let i = instruction.shift();
        let t = instruction.t();
        let d = instruction.d();

        let v = (self.reg(t) as i32) >> i;

        self.set_reg(d, v as u32);
    }
}
\end{lstlisting}

\subsection{DIV instruction}

The next unhandled instruction is \code{0x0061001a} which is
``divide'' (DIV):

\begin{lstlisting}[language=assembly]
div $3, $1
\end{lstlisting}

Multiplications and divisions are a bit peculiar on the MIPS
architecture: for one, the result is not stored in general purpose
registers but in two dedicated 32bit registers: HI and LO.

For a division LO will contain the quotient and HI the remainder of
the euclidean division.

The reason for this is that divisions and multiplications are
typically much slower than the other instructions we've implemented so
far (with the exception of loads and stores potentially, due to the
memory latency). While a simple ADD or SRA can be executed in a single
CPU cycle, DIV can take as much as 36 cycles to get the result.

In order to try and hide this delay when the CPU executes a division
instruction it does not stall the pipeline waiting for the instruction
to finish. Rather it continues executing the following instructions
and when the code decides to fetch the result of the division (using
dedicated instructions to load HI or LO) the CPU only stalls if it
didn't have the time to finish doing the division in the
background. This way if you craft your assembly cleverly you can hide
the division delay by doing some other work while the division is
finishing.

For now we haven't bothered implementing accurate timings at all so we
won't worry about these details and consider the division takes one
cycle to execute. Later on when we implement proper timings we'll have
to revisit that code.

\begin{table}[ht]
  \centering

  \begin{tabular}{ l | l | l | l }
    Numerator         & Denominator       & Quotient (LO)
    & Remainder (HI)\\
    \hline
    $ \ge 0 $         & 0                 & -1 (\code{0xffffffff})
    & \textit{numerator} \\
    $ < 0 $           & 0                 & +1
    & \textit{numerator} \\
    \code{0x80000000} & \code{0xffffffff} & \code{0x80000000}
    & 0 \\
  \end{tabular}

  \caption{Special cases in divisions}
  \label{tab:divspecial}
\end{table}

An important thing to consider is what happens when we encounter a
division by zero. Perhaps surprisingly the CPU does not generate an
exception, it just gives bogus values (1 or -1 depending on the
sign of the dividend).

An other bogus behaviour would be to divide \code{0x80000000}
(-2147483648) by \code{0xffffffff} (-1) which would yield 2147483648
which does not fit in a 32bit signed
integer. Table~\ref{tab:divspecial} gives a summary of those special
cases.

We should now have all we need to implement the instruction, let's
start by adding the HI and LO registers to our \code{Cpu}:

\begin{lstlisting}
/// CPU state
pub struct Cpu {
    //...

    /// HI register for division remainder and multiplication high
    /// result
    hi: u32,
    /// LO register for division quotient and multiplication low
    /// result
    lo: u32,
}

impl Cpu {

    pub fn new(inter: Interconnect) -> Cpu {
        //...

        Cpu {
	    //...
            hi: 0xdeadbeef,
            lo: 0xdeadbeef,
        }
    }

    //...
}
\end{lstlisting}

And now the implementation of the DIV opcode itself:

\begin{lstlisting}
impl Cpu {
    //...

    /// Divide (signed)
    fn op_div(&mut self, instruction: Instruction) {
        let s = instruction.s();
        let t = instruction.t();

        let n = self.reg(s) as i32;
        let d = self.reg(t) as i32;

        if d == 0 {
            // Division by zero, results are bogus
            self.hi = n as u32;

            if n >= 0 {
                self.lo = 0xffffffff;
            } else {
                self.lo = 1;
            }
        } else if n as u32 == 0x80000000 && d == -1 {
            // Result is not representable in a 32bit
            // signed integer
            self.hi = 0;
            self.lo = 0x80000000;
        } else {
            self.hi = (n % d) as u32;
            self.lo = (n / d) as u32;
        }
    }
}
\end{lstlisting}

\subsection{MFLO instruction}

We've seen that divisions store their results in the HI and LO
registers but we don't know how we access those yet. Unsurprisingly
the next unhandled instruction does just that: \code{0x00001812} encodes
``move from LO'' (MFLO):

\begin{lstlisting}[language=assembly]
mflo $3
\end{lstlisting}

This instruction simply moves the contents of LO in a general purpose
register. This instruction would also stall if the division was not
yet done but we'll implement that later:

\begin{lstlisting}
impl Cpu {
    //...

    /// Move From LO
    fn op_mflo(&mut self, instruction: Instruction) {
        let d = instruction.d();

        let lo = self.lo;

        self.set_reg(d, lo);
    }
}
\end{lstlisting}

\subsection{SRL instruction}

We've implemented SRA not long ago, now we encounter the sister
instruction \code{0x00057082} which is a ``shift right logical''
(SRL):

\begin{lstlisting}[language=assembly]
srl $14, $5, 2
\end{lstlisting}

It's very similiar to SRA except that the instruction treats the value
as unsigned and fills the missing MSBs with 0 after the shift. In
Rust, C and C++ we can achieve this behavior by shifting unsigned
values:

\begin{lstlisting}
impl Cpu {
    //...

    /// Shift Right Logical
    fn op_srl(&mut self, instruction: Instruction) {
        let i = instruction.shift();
        let t = instruction.t();
        let d = instruction.d();

        let v = self.reg(t) >> i;

        self.set_reg(d, v);
    }
}
\end{lstlisting}

\subsection{SLTIU instruction}

After that we meet \code{0x2c410045} which is ``set if
less than immediate unsigned'' (SLTI):

\begin{lstlisting}[language=assembly]
sltiu $1, $2, 0x45
\end{lstlisting}

It's implemented like SLTI but using unsigned integers\footnote{Note
  that the immediate is still sign extended even though it's then used
  as an unsigned value.}:

\begin{lstlisting}
impl Cpu {
    //...

    /// Set if Less Than Immediate Unsigned
    fn op_sltiu(&mut self, instruction: Instruction) {
        let i = instruction.imm_se();
        let s = instruction.s();
        let t = instruction.t();

        let v = self.reg(s) < i;

        self.set_reg(t, v as u32);
    }
}
\end{lstlisting}

\subsection{DIVU instruction}

Now we encounter the other division instruction: \code{0x0064001b}
which encodes ``divide unsigned'' (DIVU):

\begin{lstlisting}[language=assembly]
divu $3, $4
\end{lstlisting}

Since this version uses unsigned operands we only have one special
case: the division by zero (the first line in
table~\ref{tab:divspecial}). Thus the implementation is slightly
shorter than DIV:

\begin{lstlisting}
impl Cpu {
    //...

    /// Divide Unsigned
    fn op_divu(&mut self, instruction: Instruction) {
        let s = instruction.s();
        let t = instruction.t();

        let n = self.reg(s);
        let d = self.reg(t);

        if d == 0 {
            // Division by zero, results are bogus
            self.hi = n;
            self.lo = 0xffffffff;
        } else {
            self.hi = n % d;
            self.lo = n / d;
        }
    }
}
\end{lstlisting}

\subsection{MFHI instruction}

We already implemented MFLO, now we meet instruction \code{0x0000c810}
which encodes ``move from HI'' (MFHI):

\begin{lstlisting}[language=assembly]
mfhi $25
\end{lstlisting}

Like MFLO it should be able to stall if the operation has not yet
finished but we'll implement that later:

\begin{lstlisting}
impl Cpu {
    //...

    /// Move From HI
    fn op_mflo(&mut self, instruction: Instruction) {
        let d = instruction.d();

        let hi = self.hi;

        self.set_reg(d, hi);
    }
}
\end{lstlisting}

\subsection{SLT instruction}

The next unhandled instruction is \code{0x0338082a} which is ``set on
less than'':

\begin{lstlisting}[language=assembly]
slt $1, $25, $24
\end{lstlisting}

It's like SLTU but with signed operands:

\begin{lstlisting}
impl Cpu {
    //...

    /// Set on Less Than (signed)
    fn op_slt(&mut self, instruction: Instruction) {
        let d = instruction.d();
        let s = instruction.s();
        let t = instruction.t();

        let s = self.reg(s) as i32;
        let t = self.reg(t) as i32;

        let v = s < t;

        self.set_reg(d, v as u32);
    }
}
\end{lstlisting}

\subsection{Interrupt Control read}

The BIOS then attempts to read from the Interrupt Mask
register. Earlier we just ignored writes to this register (and the
Interrupt Status register) so for now we'll return 0. We'll rewrite
this code when we decide to implement interrupts:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Load 32bit word at `addr`
    pub fn load32(&self, addr: u32) -> u32 {
        //...

        if let Some(offset) = map::IRQ_CONTROL.contains(abs_addr) {
            println!("IRQ control read {:x}", offset);
            return 0;
        }

	panic!("unhandled load32 at address {:08x}", addr);
    }
}
\end{lstlisting}

\subsection{Timer registers}

After that the BIOS wants to write 0 to \code{0x1f801104}. This
address is one of the timer registers. Timers are basically just
configurable counters that can generate interrupts at a predetermined
rate. There are three independent timers on the Playstation.

For now we won't have to actually implement them though because the
BIOS just initializes them to a default disabled state by writing 0
to all the configuration registers. We can just ignore those writes
and move along:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Store 16bit halfword `val` into `addr`
    pub fn store16(&mut self, addr: u32, _: u16) {
        //...

        if let Some(offset) = map::TIMERS.contains(abs_addr) {
            println!("Unhandled write to timer register {:x}",
                     offset);
            return;
        }

        panic!("unhandled store16 into address {:08x}", addr);
    }
}
\end{lstlisting}

\subsection{Exceptions}

The next unhandled instruction is \code{0x0000000c} which encodes
a ``system call'' (SYSCALL):

\begin{lstlisting}[language=assembly]
syscall 0
\end{lstlisting}

This instruction is used to explicitly trigger an
exception. Exceptions occur when peripherals trigger an (unmasked)
interrupt, when certain error occurs (unaligned memory access,
checked overflow in certain instructions, etc\dots{}) or with commands
which are meant to trigger an exception like SYSCALL or BREAK.

When an exception occurs the following takes place in the CPU:

\begin{itemize}
  \item The current value of the PC is stored in \$cop0\_14, the EPC
    (Exception PC) register\footnote{This is not entirely accurate
    when the exception occurs in a branch delay slot. We'll review
    that case in a minute},
  \item Record the cause of the exception (syscall, overflow,
    interrupt...) in \$cop0\_13, the CAUSE register,
  \item Disable interrupts in \$cop0\_12 (SR),
  \item Jump into the exception handler whose address is either
    \code{0x80000080} or \code{0xbfc00180} depending on the value of
    the BEV field (bit 22) in \$cop0\_12 (SR).
\end{itemize}

Unlike regular jumps and branches exceptions don't have a branch delay
slot: the CPU jumps to the exception handler right after the current
instruction.

The problem is that with my current architecture we fetch an
instruction ahead of time to emulate the branch delay slot. When an
exception is triggered we'd have to replace that instruction by the
first one in the exception handler. It's possible of course but it's a
bit messy and I think it was a bad idea after all.

Instead I'm going to use two variables for the PC: one will hold he
current instruction and one will hold the ``next PC''. Normally
\code{next\_pc} is always 4 bytes ahead but when a branch occurs we'll set
the PC to the instruction in the delay slot and \code{next\_pc} to the
branch target. In case of an exception however we'll set the PC to
the exception handler address directly.

Let's change our CPU state to reflect that change:

\begin{lstlisting}
/// CPU state
pub struct Cpu {
    /// The program counter register: points to the
    /// next instruction
    pc: u32,
    /// Next value for the PC, used to simulate the
    /// branch delay slot
    next_pc: u32,
    //...
}

impl Cpu {

    pub fn new(inter: Interconnect) -> Cpu {
        //...

        // Reset value for the PC, beginning of BIOS memory
        let pc = 0xbfc00000;

        Cpu {
            pc: pc,
            next_pc: pc.wrapping_add(4),
	    //...
        }
    }

    //...
}
\end{lstlisting}

We can then (once again) rework \code{run\_next\_instruction} to use
our PC pair:

\begin{lstlisting}
impl Cpu {
    //...

    pub fn run_next_instruction(&mut self) {
        let pc = self.pc;

        // Fetch instruction at PC
        let instruction = Instruction(self.load32(pc));

        // Increment next PC to point to the next instruction.
        self.pc = self.next_pc;
        self.next_pc = self.next_pc.wrapping_add(4);

        // Execute the pending load (if any, otherwise it will load
        // `R0` which is a NOP). `set_reg` works only on `out_regs`
        // so this operation won't be visible by the next
        // instruction.
        let (reg, val) = self.load;
        self.set_reg(reg, val);

        // We reset the load to target register 0 for the next
        // instruction
        self.load = (RegisterIndex(0), 0);

        self.decode_and_execute(instruction);

        // Copy the output registers as input for the next instruction
        self.regs = self.out_regs;
    }
}
\end{lstlisting}

Then we just need to modify our branch and jump functions to set
\code{next\_pc} instead of \code{pc} to set the target address.

After that we can implement our exception infrastructure. On top of
\code{pc} and \code{next\_pc} we'll also need to store the address of
the current instruction to store it in the EPC register
(\$cop0\_14). We also need to add the CAUSE register to store the
exception code:

\begin{lstlisting}
/// CPU state
pub struct Cpu {
    //...

    /// Address of the instruction currently being executed. Used for
    /// setting the EPC in exceptions.
    current_pc: u32,
    /// Cop0 register 13: Cause Register
    cause: u32,
    /// Cop0 register 14: EPC
    epc: u32,
}

impl Cpu {
    //...

    pub fn run_next_instruction(&mut self) {
        // Fetch instruction at PC
        let instruction = Instruction(self.load32(self.pc));

        // Save the address of the current instruction to save in
        // `EPC` in case of an exception.
        self.current_pc = self.pc;

        //...
    }
}
\end{lstlisting}


Now that we've added the EPC and CAUSE registers for cop0 we can also
add them to our implementation of MFC0:

\begin{lstlisting}
impl Cpu {
    //...

    /// Move From Coprocessor 0
    fn op_mfc0(&mut self, instruction: Instruction) {
        let cpu_r = instruction.t();
        let cop_r = instruction.d().0;

        let v = match cop_r {
            12 => self.sr,
            13 => self.cause,
            14 => self.epc,
            _  =>
                panic!("Unhandled read from cop0r{}", cop_r),
        };

        self.load = (cpu_r, v)
    }
}
\end{lstlisting}

\subsection{SYSCALL instruction}

Finally we can implement our exception infrastructure and our SYSCALL
opcode. I'm going to use a \code{exception} method that will be used
from various exception sources:

\begin{lstlisting}
impl Cpu {
    //...

    /// Trigger an exception
    fn exception(&mut self, cause: Exception) {
        // Exception handler address depends on the `BEV` bit:
        let handler = match self.sr & (1 << 22) != 0 {
            true  => 0xbfc00180,
            false => 0x80000080,
        };

        // Shift bits [5:0] of `SR` two places to the left.
        // Those bits are three pairs of Interrupt Enable/User
        // Mode bits behaving like a stack 3 entries deep.
        // Entering an exception pushes a pair of zeroes
        // by left shifting the stack which disables
        // interrupts and puts the CPU in kernel mode.
        // The original third entry is discarded (it's up
        // to the kernel to handle more than two recursive
        // exception levels).
        let mode = self.sr & 0x3f;
        self.sr &= ~0x3f;
        self.sr |= (mode << 2) & 0x3f;

        // Update `CAUSE` register with the exception code (bits
        // [6:2])
        self.cause = (cause as u32) << 2;

        // Save current instruction address in `EPC`
        self.epc = self.current_pc;

        // Exceptions don't have a branch delay, we jump directly
        // into the handler
        self.pc      = handler;
        self.next_pc = self.pc.wrapping_add(4);
    }

    /// System Call
    fn op_syscall(&mut self, _: Instruction) {
        self.exception(Exception::SysCall);
    }
}

/// Exception types (as stored in the `CAUSE` register)
enum Exception {
    /// System call (caused by the SYSCALL opcode)
    SysCall = 0x8,
}
\end{lstlisting}

Our \code{op\_syscall} method ends up being a one liner. All the logic
is in the generic \code{exception} method.

With this SYSCALL instruction the BIOS enters the exception
handler. The NoCash specs tell us that we have to look at the contents
of register \$4 to know what the BIOS is supposed to do. In this case
\$4 contains 1 so it's supposed to run
``\textit{EnterCriticalSection}''. This function is apparently
supposed to disable all interrupts. Once this is done if everything
works well the exception handler should return to the caller using an
RFE instruction, let's continue and see if we find it as expected.

\subsection{MTLO instruction}

In the exception handler we stumble upon \code{0x00400013} which is
``move to LO'' (MTLO):

\begin{lstlisting}[language=assembly]
mtlo $2
\end{lstlisting}

As its name implies it just moves the value from a general purpose
register into the LO register. Be careful though because the
instruction encoding is different from MFLO:

\begin{lstlisting}
impl Cpu {
    //...

    /// Move to LO
    fn op_mtlo(&mut self, instruction: Instruction) {
        let s = instruction.s();

        self.lo = self.reg(s);
    }
}
\end{lstlisting}

It might seem surprising to encounter this instruction: why would the
BIOS want to move something \emph{into} the LO register? After all
this register is for the \emph{result} of divisions and
multiplications, you can't do anything with it besides reading it
back.

The answer is that exception handlers are not supposed to restore all
register values before returning to the ``normal'' code flow. The
reason is obvious: exceptions can be triggered by asynchronous
interrupts so they can basically happen at any time. If the exception
handler changes the value of any register before giving back the
control to the interrupted code it could lead to bogus behaviour.

For instance some game code could start a division and be interrupted
before it reads the result in LO. Then the interrupt handler needs to
compute an other division but does not restore the original value of
the register before returning the control to the game. At that point
the game reads LO expecting to get the result of its computation but
instead it gets some garbage value left there by the
handler. Obviously that would be problematic.

To avoid this the prologue of the exception handler saves the value of
the registers it might modify (including HI and LO) to the RAM and
then loads them back in the epilogue.

There are two exceptions though: registers \$26 and \$27` are reserved
for the BIOS and are not preserved by the exception handler. In other
words no code should use those registers when exceptions can occur
because their content could change at any moment.

\subsection{MTHI instruction}

Unsurprisingly the MTLO is almost immediately followed by instruction
\code{0x00400011} which is ``move to HI'' (MTHI):

\begin{lstlisting}[language=assembly]
mtlo $2
\end{lstlisting}

The implementation is almost identical to MTLO:

\begin{lstlisting}
impl Cpu {
    //...

    /// Move to HI
    fn op_mthi(&mut self, instruction: Instruction) {
        let s = instruction.s();

        self.hi = self.reg(s);
    }
}
\end{lstlisting}

\subsection{RFE intsruction}

As expected once the exception handler is done it executes instruction
\code{0x42000010} which is a coprocessor 0 opcode for ``return from
exception'' (RFE):

\begin{lstlisting}[language=assembly]
rfe
\end{lstlisting}

All this instruction does is shift the Interrupt Enable/User Mode bits
two places back to the right. This effectively undoes the opposite
shift done when entering the handler and therefore puts the CPU back
in the mode it was when the exception triggered (unless SR itself has
been modified in the handler).

It does not reset the PC however, it's up to the BIOS to fetch the
address in EPC, increment it by 4 to point at the next instruction and
jump to it. The RFE instruction is typically in the final jump delay
slot (and that's exactly what the Playstation BIOS handler does in
this case).

The instruction encoding for RFE is a bit annoying: as usual we begin
by checking bits [31:26] which are \code{0b010000} and introduce a
coprocessor opcode. Then we check bits [25:21] to figure which one it
is. For RFE it's \code{0b10000}.

But it's not over! There can be multiple instructionts with this
coprocessor encoding, although RFE is the only one implemented on the
Playstation hardware (the others have to do with virtual memory). To
make sure the requested instruction is the one we expect we must check
bits [5:0] which must be equal to \code{0b010000}:

\begin{lstlisting}
impl Cpu {
    //...

    /// Coprocessor 0 opcode
    fn op_cop0(&mut self, instruction: Instruction) {
        match instruction.cop_opcode() {
            0b00000 => self.op_mfc0(instruction),
            0b00100 => self.op_mtc0(instruction),
            0b10000 => self.op_rfe(instruction),
            _       => panic!("unhandled cop0 instruction {}", instruction)
        }
    }

    /// Return From Exception
    fn op_rfe(&mut self, instruction: Instruction) {
        // There are other instructions with the same encoding but all
        // are virtual memory related and the Playstation doesn't
        // implement them. Still, let's make sure we're not running
        // buggy code.
        if instruction.0 & 0x3f != 0b010000 {
            panic!("Invalid cop0 instruction: {}", instruction);
        }

        // Restore the pre-exception mode by shifting the Interrupt
        // Enable/User Mode stack back to its original position.
        let mode = self.sr & 0x3f;
        self.sr &= !0x3f;
        self.sr |= mode >> 2;
    }
}
\end{lstlisting}

\subsection{Exceptions and branch delay slots}

In our current implementation when an exception occurs we store the
current instruction's address in `EPC`. That's correct in most cases
but there's one exception in the MIPS archicture: when an exception
occurs in a branch delay slot we must store the address of the
\emph{branch} instruction in EPC\footnote{ This is only for
  \emph{branch} delay slots, \emph{load} delay slots behave normally
  exception-wise.}.

Consider the following sequence where we have a `SYSCALL` instruction
in a `JR` delay slot:

\begin{lstlisting}[language=assembly]
    jr $ra
    syscall
\end{lstlisting}

In this case the CPU will put the address of the \code{jr \$ra}
instruction in EPC before entering the exception handler. In order to
signal this condition to the handler the CPU also sets bit 31 of the
CAUSE register.

In order to implement this behaviour we first need to keep track of
whether or we're in a branch delay slot. It's tempting to just check
whether or not the next instruction is 4 bytes ahead of the current
one but it's technically possible to branch 4 bytes ahead, even though
it wouldn't be very useful. Instead I'm going to play it safe and add
new variables:

\begin{lstlisting}
pub struct Cpu {
    //...

    /// Set by the current instruction if a branch occured and the
    /// next instruction will be in the delay slot.
    branch: bool,
    /// Set if the current instruction executes in the delay slot
    delay_slot: bool,
}

impl Cpu {

    pub fn new(inter: Interconnect) -> Cpu {
        //...

        Cpu {
            //...
            branch:     false,
            delay_slot: false,
        }
    }

    pub fn run_next_instruction(&mut self) {
        //...
        let instruction = Instruction(self.load32(self.pc));

        // If the last instruction was a branch then we're in the
        // delay slot
        self.delay_slot = self.branch;
        self.branch     = false;

        self.decode_and_execute(instruction);

        //...
    }

    //...
}
\end{lstlisting}

Now we can simply modify (once again) all the branch and jump
instructions to set \code{self.branch = true}. In the next cycle
\code{run\_next\_instruction} will copy this variable to
\code{self.delay\_slot}.

Now that we keep track of delay slots we can modify our exception code
to handle them accurately:

\begin{lstlisting}
impl Cpu {
    //...

    /// Trigger an exception
    fn exception(&mut self, cause: Exception) {
        //...

        // Update `CAUSE` register with the exception code (bits
        // [6:2])
        self.cause = (cause as u32) << 2;

        // Save current instruction address in `EPC`
        self.epc = self.current_pc;

        if self.delay_slot {
            // When an exception occurs in a delay slot `EPC` points
            // to the branch instruction and bit 31 of `CAUSE` is set.
            self.epc = self.epc.wrapping_sub(4);
            self.cause |= 1 << 31;
        }

        //...
    }
}
\end{lstlisting}

With our exception handling infrastructure in place we can take the
opportunity to review some exception conditions we've ignored so far
and implement them accurately.

\subsection{ADD and ADDI overflows}

The ADD and ADDI opcodes generate an exception on signed overflow but
in our current implementation is incomplete. We can use our
\code{exception} method to handle them in full:

\begin{lstlisting}
impl Cpu {
    //...

    /// Add and check for signed overflow
    fn op_add(&mut self, instruction: Instruction) {
        let s = instruction.s();
        let t = instruction.t();
        let d = instruction.d();

        let s = self.reg(s) as i32;
        let t = self.reg(t) as i32;

        match s.checked_add(t) {
            Some(v) => self.set_reg(d, v as u32),
            None    => self.exception(Exception::Overflow),
        }
    }

    /// Add Immediate and check for signed overflow
    fn op_addi(&mut self, instruction: Instruction) {
        let i = instruction.imm_se() as i32;
        let t = instruction.t();
        let s = instruction.s();

        let s = self.reg(s) as i32;

        match s.checked_add(i) {
            Some(v) => self.set_reg(t, v as u32),
            None    => self.exception(Exception::Overflow),
        }
    }
}

/// Exception types (as stored in the `CAUSE` register)
enum Exception {
    //...

    /// Arithmetic overflow
    Overflow = 0xc,
}
\end{lstlisting}

\subsection{Store and load alignment exceptions}

When a load or store instruction targets a misaligned address (i.e. a
word access address is not a multiple of 4 or a halfword access
address is not a multiple of 2) the CPU is supposed to generate an
exception:

\begin{lstlisting}
impl Cpu {
    //...

    /// Load Word
    fn op_lw(&mut self, instruction: Instruction) {
        //...

        // Address must be 32bit aligned
        if addr % 4 == 0 {
            let v = self.load32(addr);

            // Put the load in the delay slot
            self.load = (t, v);
        } else {
            self.exception(Exception::LoadAddressError);
        }
    }

    /// Store Halfword
    fn op_sh(&mut self, instruction: Instruction) {
        //...

        // Address must be 16bit aligned
        if addr % 2 == 0 {
            self.store16(addr, v as u16);
        } else {
            self.exception(Exception::StoreAddressError);
        }
    }

    /// Store Word
    fn op_sw(&mut self, instruction: Instruction) {
        //...

        // Address must be 32bit aligned
        if addr % 4 == 0 {
            self.store32(addr, v);
        } else {
            self.exception(Exception::StoreAddressError);
        }
    }
}

/// Exception types (as stored in the `CAUSE` register)
enum Exception {
    //...

    /// Address error on load
    LoadAddressError = 0x4,
    /// Address error on store
    StoreAddressError = 0x5,
}
\end{lstlisting}

\subsection{PC alignment exception}

We should also generate an exception if the PC address is not
correctly aligned when we attempt to fetch an instruction. This can
happen if a JR or JALR instruction jumped to an address that was not
32bit aligned\footnote{It might be more efficient to add the test in
  the branch and jump instructions capable of setting an invalid PC
  but I don't really care about performance at that point and that
  would make the code more complicated}:

\begin{lstlisting}
impl Cpu {
    //...

    pub fn run_next_instruction(&mut self) {
        // Save the address of the current instruction to save in
        // `EPC` in case of an exception.
        self.current_pc = self.pc;

        if self.current_pc % 4 != 0 {
            // PC is not correctly aligned!
            self.exception(Exception::LoadAddressError);
            return;
        }

        // Fetch instruction at PC
        let instruction = Instruction(self.load32(self.pc));

        //...
    }
}
\end{lstlisting}

\subsection{RAM 16bit store}

If the exceptions are implemented correctly our next unhandled
condition should be a SH targeting address \code{0x800dee24}. This
address is in the RAM so we just need to add 16bit store support for
it:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Store 16bit halfword `val` into `addr`
    pub fn store16(&mut self, addr: u32, val: u16) {

        let abs_addr = map::mask_region(addr);

        if let Some(offset) = map::RAM.contains(abs_addr) {
            return self.ram.store16(offset, val);
        }

        //...
    }
}
\end{lstlisting}

And then in our RAM implementation:

\begin{lstlisting}
impl Ram {
    //...

    /// Store the 16bit little endian halfword `val` into `offset`
    pub fn store16(&mut self, offset: u32, val: u16) {
        let offset = offset as usize;

        let b0 = val as u8;
        let b1 = (val >> 8) as u8;

        self.data[offset + 0] = b0;
        self.data[offset + 1] = b1;
    }
}
\end{lstlisting}

As always, make sure you get the endianess right.

\subsection{DMA registers}

We then stumble upon an unhandled load from address
\code{0x1f8010f0}. Looking at the memory map this is the ``DMA control
register''. DMA stands for
\href{https://en.wikipedia.org/wiki/Direct_memory_access}{Direct
  Memory Access}. This is a generic term which can mean different
things on different architectures but the concept is always the same:
it's used to move data between a peripheral and RAM without directly
involving the CPU.

For instance if a game wants to load a texture to the GPU memory it
can set up the DMA to do the copy instead of doing it from the CPU
with a series of LW/SW. This is generally faster since the DMA is
usually more efficient for moving data around and while it's working
the CPU can do more interesting things\footnote{Although on the
  Playstation the CPU is seriously gimped while the DMA is running as
  we'll see later}.

Since we still have some work to do on the CPU let's see if we can
ignore the DMA access for now:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Load 32bit word at `addr`
    pub fn load32(&self, addr: u32) -> u32 {
        //...

        if let Some(_) = map::DMA.contains(abs_addr) {
            println!("DMA read: {:08x}", abs_addr);
            return 0;
        }

        panic!("unhandled load32 at address {:08x}", addr);
    }
}

/// Direct Memory Access registers
pub const DMA: Range = Range(0x1f801080, 0x80);
\end{lstlisting}

You'll notice that I ignore \emph{all} loads from \emph{any} DMA
register, not just the control. Let's hope we'll be able to keep the
smoke screen up for a little longer.

Soon after that we encounter a SW targeting the DMA control register
with the value \code{0x000b0000}. This value configures the DMA SPU
channel priority and enables it. This probably means the BIOS is
getting ready to play some sound. Since we don't care about the SPU or
the DMA at that point let's ignore those writes as well:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Store 32bit word `val` into `addr`
    pub fn store32(&mut self, addr: u32, val: u32) {
        //...

        if let Some(_) = map::DMA.contains(abs_addr) {
            println!("DMA write: {:08x} {:08x}", abs_addr, val);
            return;
        }

        panic!("unhandled store32 into address {:08x}: {:08x}", addr, val);
    }
}
\end{lstlisting}

Hopefuly we should be able to ignore the DMA for a while and keep
focusing on the CPU.

\subsection{LHU instruction}

The next unhandled instruction is \code{0x961901ae} which is ``load
halfword unsigned'' (LHU):

\begin{lstlisting}[language=assembly]
lhu $25, 430($16)
\end{lstlisting}

It's the 16bit counterpart to LBU and it's our first 16bit load
istruction:

\begin{lstlisting}
impl Cpu {
    //...

    /// Load 16bit value from the memory
    fn load16(&self, addr: u32) -> u16 {
        self.inter.load16(addr)
    }

    /// Load Halfword Unsigned
    fn op_lhu(&mut self, instruction: Instruction) {

        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);

        // Address must be 16bit aligned
        if addr % 2 == 0 {
            let v = self.load16(addr);

            // Put the load in the delay slot
            self.load = (t, v as u32);
        } else {
            self.exception(Exception::LoadAddressError);
        }
    }
}
\end{lstlisting}

We need to implement \code{load16} in the interconnect. The current
instruction attempts to load from \code{0x1f801dae} which is the SPU
status register. Let's lie once again and return 0 for SPU reads:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Load 16bit halfword at `addr`
    pub fn load16(&self, addr: u32) -> u16 {
        let abs_addr = map::mask_region(addr);

        if let Some(_) = map::SPU.contains(abs_addr) {
            println!("Unhandled read from SPU register {:08x}",
                     abs_addr);
            return 0;
        }

        panic!("unhandled load16 at address {:08x}", addr);
    }
}
\end{lstlisting}

If we continue the emulation we stumble on an other unhandled
\code{load16}, this time at address \code{0x800dee24}. This one is
easy, it's RAM:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Load 16bit halfword at `addr`
    pub fn load16(&self, addr: u32) -> u16 {
        //...

        if let Some(offset) = map::RAM.contains(abs_addr) {
            return self.ram.load16(offset);
        }

        panic!("unhandled load16 at address {:08x}", addr);
    }

}
\end{lstlisting}

And in our RAM implementation:

\begin{lstlisting}
impl Ram {
    //...

    /// Fetch the 16bit little endian halfword at `offset`
    pub fn load16(&self, offset: u32) -> u16 {
        let offset = offset as usize;

        let b0 = self.data[offset + 0] as u16;
        let b1 = self.data[offset + 1] as u16;

        b0 | (b1 << 8)
    }
}
\end{lstlisting}

\subsection{SLLV instruction}

After that we encounter \code{0x0078c804} which is ``shift left
logical variable'' (SLLV):

\begin{lstlisting}[language=assembly]
sllv $25, $24, $3
\end{lstlisting}

It's like SLL except the shift amount is stored in a register instead
of an immediate value.

The implementation is quite simple but there's something to consider:
so far the shift amount was always a 5bit immediate value but this
time it's a 32bit register. What happens when the register value is
greater than 31?

It's also important to figure out because shifting out of range is
undefined in Rust (and in C) so we have to be careful not to introduce
weird undefined behavior in our emulator.

Shifting by more than 31 places would mean shifting the 32bit value
completely out of range. Intuitively you might say that it sets it to
0 (all significant bits get shifted \emph{outside} the register) but
it turns out it's not accurate.

In reality on the R3000 CPU the shift amount is always implicitly
masked with \texttt{0x1f} to only keep the low 5 bits. It means that
a shift amount of 32 behaves like 0 (i.e. it's a NOP) while 130
behaves like 2:

\begin{lstlisting}
impl Cpu {
    //...

    /// Shift Left Logical Variable
    fn op_sllv(&mut self, instruction: Instruction) {
        let d = instruction.d();
        let s = instruction.s();
        let t = instruction.t();

        // Shift amount is truncated to 5 bits
        let v = self.reg(t) << (self.reg(s) & 0x1f);

        self.set_reg(d, v);
    }
}
\end{lstlisting}

\subsection{LH instruction}

We implemented LHU not long ago and now we meet \code{0x87a30018}
which is ``load halfword'' (LH):

\begin{lstlisting}[language=assembly]
lh $3, 24($29)
\end{lstlisting}

It's implemented like LHU but it sign-extends the 16bit value to fit
the 32bit target register:

\begin{lstlisting}
impl Cpu {
    //...

    /// Load Halfword (signed)
    fn op_lh(&mut self, instruction: Instruction) {

        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);

        // Cast as i16 to force sign extension
        let v = self.load16(addr) as i16;

        // Put the load in the delay slot
        self.load = (t, v as u32);
    }
}
\end{lstlisting}

\subsection{NOR instruction}

After that we stumble upon \code{0x0040c827} which is ``bitwise not
or'' (NOR):

\begin{lstlisting}[language=assembly]
nor $25, $2, $zero
\end{lstlisting}

It simply computes a bitwise OR between two registers and then
complements the result before storing it in the destination
register\footnote{Note that in this context \code{!} in rust does the
  same thing as \code{\~{}} in C: it's the \emph{bitwise} NOT
  operator.}:

\begin{lstlisting}
impl Cpu {
    //...

    /// Bitwise Not Or
    fn op_nor(&mut self, instruction: Instruction) {
        let d = instruction.d();
        let s = instruction.s();
        let t = instruction.t();

        let v = !(self.reg(s) | self.reg(t));

        self.set_reg(d, v);
    }
}
\end{lstlisting}

\subsection{SRAV instruction}

The next unhandled instruction is \code{0x00e84007} which encodes
``shift right arithmetic variable'' (SRAV):

\begin{lstlisting}[language=assembly]
srav $8, $8, $7
\end{lstlisting}

We've already implemented SRA and SLLV so this one shouldn't give us
any trouble:

\begin{lstlisting}
impl Cpu {
    //...

    /// Shift Right Arithmetic Variable
    fn op_srav(&mut self, instruction: Instruction) {
        let d = instruction.d();
        let s = instruction.s();
        let t = instruction.t();

        // Shift amount is truncated to 5 bits
        let v = (self.reg(t) as i32) >> (self.reg(s) & 0x1f);

        self.set_reg(d, v as u32);
    }
}
\end{lstlisting}

\subsection{SRLV instruction}

We finally encounter the last shift instruction: \code{0x01a52806} is
``shift right logical variable'' (SRLV):

\begin{lstlisting}[language=assembly]
srlv $5, $5, $13
\end{lstlisting}

It's implemented like SRAV without sign extension (or like SRL with a
register holding the shift amount, if you prefer):

\begin{lstlisting}
impl Cpu {
    //...

    /// Shift Right Logical Variable
    fn op_srlv(&mut self, instruction: Instruction) {
        let d = instruction.d();
        let s = instruction.s();
        let t = instruction.t();

        // Shift amount is truncated to 5 bits
        let v = self.reg(t) >> (self.reg(s) & 0x1f);

        self.set_reg(d, v);
    }
}
\end{lstlisting}

\subsection{MULTU instruction}

The next unhandled instruction is \code{0x01240019} which encodes
``multiply unsigned'' (MULTU):

\begin{lstlisting}[language=assembly]
multu $9, $4
\end{lstlisting}

It's our first multiplication opcode. The CPU does the multiplication
using 64bit arithmetics and store the result across the HI and LO
registers:

\begin{lstlisting}
impl Cpu {
    //...

    /// Multiply Unsigned
    fn op_multu(&mut self, instruction: Instruction) {
        let s = instruction.s();
        let t = instruction.t();

        let a = self.reg(s) as u64;
        let b = self.reg(t) as u64;

        let v = a * b;

        self.hi = (v >> 32) as u32;
        self.lo = v as u32;
    }
}
\end{lstlisting}

The timings of the multiplication instructions are similar to the
divisions: they run in the background and only stall the CPU if it
attempts to read the LO or HI registers before it's done. Since we
don't implement accurate CPU timings I choose to ignore that for now.

\subsection{GPU registers}

Our next stop will be an unhandled LW at address
\code{0x1f801814}. This register is GPUSTAT when read and GP1 when
written. In other words GPUSTAT is read only while GP1 is write only
and they share the same address. Why not.

GPUSTAT contains a whole bunch of information about the GPU
status. Things like the display's resolution and color depth,
interlacing, DMA channel status and more.

It seems we're entering to the display initialization code, we might
soon be pushing our first pixels to the screen! Boot logo, here we
come.

Well, let's not get ahead of ourselves, for now we have zero GPU
emulation code so we're going to use the usual deception and have the
BIOS read zeroes when it attempts to access the GPU register
space. That's easy, there are only two registers in the GPU (well,
four really: two read only and two write only sharing the same
addresses):

\begin{lstlisting}
impl Interconnect {
    //...

    /// Load 32bit word at `addr`
    pub fn load32(&self, addr: u32) -> u32 {
        //...

        if let Some(offset) = map::GPU.contains(abs_addr) {
            println!("GPU read {}", offset);
            return 0;
        }

        panic!("unhandled load32 at address {:08x}", addr);
    }
}
\end{lstlisting}

\subsubsection{GP0 register}

Very soon after that we get an unhandled \code{write32} at address
\code{0x1f801810}. This is the other GPU register address. This one is
GP0 for writing and it's used to queue commands.

We'll study the GPU more closely soon but for now it suffices to say
that it's programmed differently from the other peripherals we've seen
so far: instead of having dedicated registers for the various
function, the CPU (or DMA) queues commands in one of the two ports
(GP0 and GP1) which behave like FIFOs. The GPU then executes the
commands one after an other.

Commands include drawing triangles, lines and sprites with various
attributes but also things like interrupt management and display
configuration.

In order to interpret a GPU command we must first see to which port it
was posted (GP0 in this case). Then we must look at the value:
\code{0xe1001000} here. The high byte (0xe1) is the ``opcode'', the
remaining 24bits are parameters whose meaning depends on the command.

This particular opcode is ``Draw Mode Setting''. It mostly sets a
bunch of texture-related parameters. In this particular instance only
bit 12 is set which activates ``Textured Rectangle X-Flip''. Not
exactly obvious why the BIOS is doing this right now but I guess we'll
figure out that soon.

For now we're still working on our CPU, so let's just ignore writes to
the GPU ports and hope we can get away with it:


\begin{lstlisting}
impl Interconnect {
    //...

    /// Store 32bit word `val` into `addr`
    pub fn store32(&mut self, addr: u32, val: u32) {
        //...

        if let Some(offset) = map::GPU.contains(abs_addr) {
            println!("GPU write {}: {:08x}", offset, val);
            return;
        }

        panic!("unhandled store32 into address {:08x}: {:08x}", addr, val);
    }
}
\end{lstlisting}

\subsection{Interrupt Control 16bit access}

Unfortunately we don't go very far, the BIOS then wants to make a
16bit read at the Interrupt Mask address. So far we've only
implemented 32bit access so let's add halfword support:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Load 16bit halfword at `addr`
    pub fn load16(&self, addr: u32) -> u16 {
        //...

        if let Some(offset) = map::IRQ_CONTROL.contains(abs_addr) {
            println!("IRQ control read {:x}", offset);
            return 0;
        }
    }
}
\end{lstlisting}

Unsurprisingly it's followed by a 16 bit write to the same address
with the value 1. This means that the BIOS wants to use the first
interrupt which is the vertical blanking interrupt generated by the
GPU's video output. As usual let's ignore that:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Store 16bit halfword `val` into `addr`
    pub fn store16(&mut self, addr: u32, val: u16) {
        //...

        if let Some(offset) = map::IRQ_CONTROL.contains(abs_addr) {
            println!("IRQ control write {:x}, {:04x}", offset, val);
            return;
        }
    }
}
\end{lstlisting}

\subsection{Timer registers 32bit access}

After that we get an unhandled 32bit access to the timers range.

This time the BIOS wants to store \code{0xffffffff} at
\code{0x1f801118} which is the counter target value for timer 1. When
the counter reaches that value it goes back to 0 and optionally
generates an interrupt. The counter is only 16bit wide though so this
write would actually set the target value to \code{0xffff} and the
upper 16bits are ignored.

Let's add our usual placeholder code:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Store 32bit word `val` into `addr`
    pub fn store32(&mut self, addr: u32, val: u32) {
        //...

        if let Some(offset) = map::TIMERS.contains(abs_addr) {
            println!("Unhandled write to timer register {:x}: {:08x}",
                     offset, val);
            return;
        }
    }
}
\end{lstlisting}

After that the BIOS writes \code{0x148} to \code{0x1f801114} which
sets the timer 1 mode. Bit \code{0x8} clears the counter (resets it to
0), bit \code{0x40} sets the timer interrupt to repeat mode which
means that it will fire periodically when the counter reaches the
target. Finally bit \code{0x100} sets the clock source as ``horizontal
blanking''. It means that the timer increments when the display
reaches the horizontal blanking period.

This doesn't set bit \code{0x10} however which would actually enable
the interrupt. And it hasn't attempted to unmask the interrupt in the
Interrupt Mask register either anyway. Not sure where the BIOS is
going with this.

After that the BIOS tries to change the value of the Interrupt Mask
and enables interrupt \code{0x8} which is the DMA's.

\subsection{GPUSTAT ``DMA ready'' field}

At this point the BIOS enters an infinite loop: it reads the GPUSTAT
register again and again. Obviously it's waiting for something to
happen but since we only ever return 0 it deadlocks.

If we disassemble that loop the code looks like this (it's in the BIOS
at address \code{0xbfc04190}):

\begin{lstlisting}[language=assembly]
lw $8, 0($6)     /* Here $6 is equal to 0x1f801814 (GPUSTAT) */
nop              /* load delay slot */
and $9, $8, $4   /* Here $4 contains 0x10000000 */
beq $9, $0, -44  /* Loop back if $9 is zero */
\end{lstlisting}

There are more things in the loop but that's the important part. We
can see that the BIOS loads GPUSTAT, masks bit 28 and loops if it's 0.

If we look at the specs we can see that bit 28 of GPUSTAT tells if the
GPU is ready to receive a DMA block. So it seems that the BIOS is
polling this bit in GPUSTAT because it's about to initiate a DMA
transfer between the RAM and the GPU.

Let's modify our GPUSTAT handling code to return \code{0x10000000}
when read:

\begin{lstlisting}
impl Interconnect {
    //...

    /// Load 32bit word at `addr`
    pub fn load32(&self, addr: u32) -> u32 {
        //...

        if let Some(offset) = map::GPU.contains(abs_addr) {
	    println!("GPU read {}", offset);
            return match offset {
                // GPUSTAT: set bit 28 to signal that the GPU is ready
                // to receive DMA blocks
                4 => 0x10000000,
                _ => 0,
            }
        }

        //...
    }
}
\end{lstlisting}

This lets the BIOS continue the execution a little further.

\subsection{XOR instruction}

We then encounter an unhandled instruction: \code{0x0303c826} which
encodes an ``exclusive or'' (XOR):

\begin{lstlisting}[language=assembly]
xor $25, $24, $3
\end{lstlisting}

We can implement it by copying the OR method and replacing the
\code{|} operator with \code{\^{}}:

\begin{lstlisting}
mod Cpu {
    //...

    /// Bitwise Exclusive Or
    fn op_xor(&mut self, instruction: Instruction) {
        let d = instruction.d();
        let s = instruction.s();
        let t = instruction.t();

        let v = self.reg(s) ^ self.reg(t);

        self.set_reg(d, v);
    }
}
\end{lstlisting}

With this instruction implemented the BIOS then goes on to write a
bunch of DMA registers and then gets stuck in an other infinite loop,
polling GPUSTAT once again.

We could look at what the BIOS is doing once again to try and figure
out the right value to return to let it continue but that would be a
bit pointless at that point. We've almost implemented all the CPU
instructions anyway and we've reach the part of the BIOS where the
bootup logo is drawn. We need to implement the DMA to send the
commands to the GPU and then emulate the GPU itself to accept those
commands and draw on the screen.

Before we move on though let's implement the handful of CPU opcodes we
haven't yet encountered. At this point we've implemented 48 opcodes
and 19 are remaining.  Fortunately most of those are variations of
instructions we've already implemented so let's get this over with.

\subsection{BREAK instructions}

BREAK triggers an exception like SYSCALL but it sets code 9 in the
CAUSE register. This instruction is generally meant to create software
breakpoints in code for debugging purposes but I imagine some games
might abuse it for other purposes.

This instruction is encoded by setting bits [31:26] of the
instruction to zero and bits [5:0] to \code{0xd}.

\begin{lstlisting}
impl Cpu {
    //...

    /// Break
    fn op_break(&mut self, _: Instruction) {
        self.exception(Exception::Break);
    }
}

/// Exception types (as stored in the `CAUSE` register)
enum Exception {
    //...

    /// Breakpoint (caused by the BREAK opcode)
    Break = 0x9,
}
\end{lstlisting}

\subsection{MULT instruction}

``Multiply'' (MULT) is simply the signed counterpart to MULTU. It
multiplies its operands using 64bit signed arithmetics and stores
stores the result in HI and LO.

This instruction is encoded by setting bits [31:26] of the
instruction to zero and bits [5:0] to \code{0x18}.

\begin{lstlisting}
impl Cpu {
    //...

    /// Multiply (signed)
    fn op_mult(&mut self, instruction: Instruction) {
        let s = instruction.s();
        let t = instruction.t();

        let a = (self.reg(s) as i32) as i64;
        let b = (self.reg(t) as i32) as i64;

        let v = (a * b) as u64;

        self.hi = (v >> 32) as u32;
        self.lo = v as u32;
    }
}
\end{lstlisting}

All those casts are a bit ugly but they're necessary to get the proper
sign extension.

\subsection{SUB instruction}

``Substract'' (SUB) is like SUBU but with signed arithmetics
\emph{and} it triggers an exception on signed overflow.

This instruction is encoded by setting bits [31:26] of the
instruction to zero and bits [5:0] to \code{0x22}.

\begin{lstlisting}
impl Cpu {
    //...

    /// Substract and check for signed overflow
    fn op_sub(&mut self, instruction: Instruction) {
        let s = instruction.s();
        let t = instruction.t();
        let d = instruction.d();

        let s = self.reg(s) as i32;
        let t = self.reg(t) as i32;

        match s.checked_sub(t) {
            Some(v) => self.set_reg(d, v as u32),
            None    => self.exception(Exception::Overflow),
        }
    }
}
\end{lstlisting}

\subsection{XORI instruction}

``Exclusive or immediate'' (XORI) is the version of the XOR
instruction taking an immediate operand. We can implement it by taking
the code for ORI and changing the operator.

This instruction is encoded by setting bits [31:26] of the
instruction to \code{0xe}.

\begin{lstlisting}
impl Cpu {
    //...

    /// Bitwise eXclusive Or Immediate
    fn op_xori(&mut self, instruction: Instruction) {
        let i = instruction.imm();
        let t = instruction.t();
        let s = instruction.s();

        let v = self.reg(s) ^ i;

        self.set_reg(t, v);
    }
}
\end{lstlisting}

\subsection{Cop1, cop2 and cop3 opcodes}

We've implemented cop0 instructions (MTC0, RFE etc\dots{}). The three
other coprocessors can also have dedicated opcodes. On the Playstation
however cop1 and cop3 are not used so any instruction targeting them
will trigger an exception with code \code{0xb} to signal a coprocessor
error..

Cop1 and cop3 opcodes are encoded by setting bits [31:26] of the
instruction to \code{0x11} and \code{0x13} respectively.

\begin{lstlisting}
impl Cpu {
    //...

    /// Coprocessor 1 opcode (does not exist on the Playstation)
    fn op_cop1(&mut self, _: Instruction) {
        self.exception(Exception::CoprocessorError);
    }

    /// Coprocessor 3 opcode (does not exist on the Playstation)
    fn op_cop3(&mut self, _: Instruction) {
        self.exception(Exception::CoprocessorError);
    }
}

/// Exception types (as stored in the `CAUSE` register)
enum Exception {
    //...

    /// Unsupported coprocessor operation
    CoprocessorError = 0xb,
}
\end{lstlisting}

Cop2 however is implemented on the Playstation: it's the Geometry
Transform Engine (GTE). We don't need to implement the GTE for now so
let's just add a dummy implementation that will crash the emulator if
a GTE instruction is encountered.

Cop opcodes are encoded by setting bits [31:26] of the
instruction to \code{0x12}.

\begin{lstlisting}
impl Cpu {
    //...

    /// Coprocessor 2 opcode (GTE)
    fn op_cop2(&mut self, instruction: Instruction) {
        panic!("unhandled GTE instruction: {}", instruction);
    }
}
\end{lstlisting}

\subsection{Non-aligned reads}

So far we've seen that all CPU memory transactions had to be properly
aligned or they would trigger an exception. The MIPS instruction set
does however have limited support for unaligned access. For unaligned
reads it provides ``load word left'' (LWL) and ``load word right''
(LWR).

Both those instruction work by fetching the \emph{aligned} word
containing the addressed byte and then shifting the value to only
update the correct portion of the target register.

Therefore in order to load a single unaligned word you need to run a
both a LWL and a LWR in sequence (the order doesn't matter) to fetch
the 32bits.

The behaviour of both these instructions changes depending on whether
the CPU is running in big or little-endian mode. Since the PSX runs
exclusively in little endian we can ignore the other case.

For a little endian architecture and assuming \$2 contains the
potentially unaligned load address the sequence would look like this:

\begin{lstlisting}[language=assembly]
/* Load right part of potentially unaligned word at $2 */
lwr $1, 0($2)
/* Load left part of potentially unaligned word at $2 */
lwl $1, 3($2)
\end{lstlisting}

After this sequence \$1 contains the 4byte little endian value at the
address stored in \$2 regardless of its alignment.

You can see that the LWL instruction is given an offset of 3. If the
address was correctly aligned we remain within the same \emph{aligned}
32bit word, otherwise we've moved to the next one.

Okay, that might sound a bit complicated, hopefully everything will be
clearer when we see the code of the implementation.

Before that however it's important to note a specificity of these
unaligned word instructions: you'll notice that in my asm snippet
above I run the two instructions back-to-back without delay. That's
because those instructions can merge their data with that of a pending
load without having to wait for the load to finish.

For other load instructions it wouldn't make a lot of sense (why would
you want to load twice to the same target register without doing
anything with the first value?) but since LWL and LWR are meant to be
used together to load a single value it makes sense to spare a cycle
there\footnote{Interesting bit of trivia: apparently the LWL and LWR
  instructions were
  \href{https://encrypted.google.com/patents/US4814976}{patented}. The
  patent expired in 2006 and
  \href{https://www.linux-mips.org/archives/linux-mips/2003-05/msg00189.html}{some
    people} claimed that it might also have covered software
  implementations. If that's true it means one could not have
  distributed our emulator without a license from MIPS Computer
  Systems.}.

\subsubsection{LWL instruction}

The ``load word left'' (LWL) opcode is encoded by setting bits [31:26]
of the instruction to \code{0x22}.

\begin{lstlisting}
impl Cpu {
    //...

    /// Load Word Left (little-endian only implementation)
    fn op_lwl(&mut self, instruction: Instruction) {

        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);

        // This instruction bypasses the load delay restriction: this
        // instruction will merge the new contents with the value
        // currently being loaded if need be.
        let cur_v = self.out_regs[t.0 as usize];

        // Next we load the *aligned* word containing the first
        // addressed byte
        let aligned_addr = addr & !3;
        let aligned_word = self.load32(aligned_addr);

        // Depending on the address alignment we fetch the 1, 2, 3 or
        // 4 *most* significant bytes and put them in the target
        // register.
        let v = match addr & 3 {
            0 => (cur_v & 0x00ffffff) | (aligned_word << 24),
            1 => (cur_v & 0x0000ffff) | (aligned_word << 16),
            2 => (cur_v & 0x000000ff) | (aligned_word << 8),
            3 => (cur_v & 0x00000000) | (aligned_word << 0),
            _ => unreachable!(),
        };

        // Put the load in the delay slot
        self.load = (t, v);
    }
}
\end{lstlisting}

Hopefully the comments are clear enough to follow what the code is
doing. You can see that LWL updates one, two, three or all four bytes
in the target register depending on the address alignment.

Note the direct reference to \code{self.out\_regs} instead of our usual
helper to make sure we ignore the load delay when the two instructions
are used in sequence.

\subsubsection{LWR instruction}

The ``load word right'' (LWR) opcode is encoded by setting bits
[31:26] of the instruction to \code{0x26}. The implementation is very
similar to LWL with a few key changes:

\begin{lstlisting}
impl Cpu {
    //...

    /// Load Word Right (little-endian only implementation)
    fn op_lwr(&mut self, instruction: Instruction) {

        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);

        // This instruction bypasses the load delay restriction: this
        // instruction will merge the new contents with the value
        // currently being loaded if need be.
        let cur_v = self.out_regs[t.0 as usize];

        // Next we load the *aligned* word containing the first
        // addressed byte
        let aligned_addr = addr & !3;
        let aligned_word = self.load32(aligned_addr);

        // Depending on the address alignment we fetch the 1, 2, 3 or
        // 4 *least* significant bytes and put them in the target
        // register.
        let v = match addr & 3 {
            0 => (cur_v & 0x00000000) | (aligned_word >> 0),
            1 => (cur_v & 0xff000000) | (aligned_word >> 8),
            2 => (cur_v & 0xffff0000) | (aligned_word >> 16),
            3 => (cur_v & 0xffffff00) | (aligned_word >> 24),
            _ => unreachable!(),
        };

        // Put the load in the delay slot
        self.load = (t, v);
    }
}
\end{lstlisting}

You can see that like LWL we update from one to four bytes depending
on the alignment, however this time it's the least significant bytes.

\subsection{Non-aligned writes}

Naturally the MIPS instruction set doesn't only support loading
non-aligned words, it can also store them using ``store word left''
(SWL) and ``store word right'' (SWR).

The concept is the same: to store a 32bit integer at an unaligned
access one would call SWR and SWL in sequence to update the entire
word.

\subsubsection{SWL instruction}

The ``store word left'' (SWL) opcode is encoded by setting bits
[31:26] of the instruction to \code{0x2a}. Since we only update part
of the \emph{aligned} target word we have to fetch its value before we
can modify it and store it back again:

\begin{lstlisting}
impl Cpu {
    //...

    /// Store Word Left (little-endian only implementation)
    fn op_swl(&mut self, instruction: Instruction) {

        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);
        let v    = self.reg(t);

        let aligned_addr = addr & !3;
        // Load the current value for the aligned word at the target
        // address
        let cur_mem = self.load32(aligned_addr);

        let mem = match addr & 3 {
            0 => (cur_mem & 0xffffff00) | (v >> 24),
            1 => (cur_mem & 0xffff0000) | (v >> 16),
            2 => (cur_mem & 0xff000000) | (v >> 8),
            3 => (cur_mem & 0x00000000) | (v >> 0),
            _ => unreachable!(),
        };

        self.store32(addr, mem);
    }
}
\end{lstlisting}

\subsubsection{SWR instruction}

The ``store word right'' (SWR) opcode is encoded by setting bits
[31:26] of the instruction to \code{0x2e}. It's very similar to SWL
except for a a few key differences:

\begin{lstlisting}
impl Cpu {
    //...

    /// Store Word Right (little-endian only implementation)
    fn op_swr(&mut self, instruction: Instruction) {

        let i = instruction.imm_se();
        let t = instruction.t();
        let s = instruction.s();

        let addr = self.reg(s).wrapping_add(i);
        let v    = self.reg(t);

        let aligned_addr = addr & !3;
        // Load the current value for the aligned word at the target
        // address
        let cur_mem = self.load32(aligned_addr);

        let mem = match addr & 3 {
            0 => (cur_mem & 0x00000000) | (v << 0),
            1 => (cur_mem & 0x000000ff) | (v << 8),
            2 => (cur_mem & 0x0000ffff) | (v << 16),
            3 => (cur_mem & 0x00ffffff) | (v << 24),
            _ => unreachable!(),
        };

        self.store32(addr, mem);
    }
}
\end{lstlisting}

\subsection{Coprocessor loads and stores}

We've seen that MTC0 and MFC0 can be used to move data between the
general purpose registers and the coprocessor 0. That means that if
you want to load or store a cop0 register value from or to the memory
we have to pass through the CPU general purpose registers.

The coprocessor 2 (the GTE) supports an additional, more optimized way
to do this: ``load word to coprocessor 2'' (LWC2) and ``store word
from coprocessor 2''(SWC2). Those instructions respectively load and
store a cop2 register directly from and to memory.

Since the other coprocessors don't support these opcodes they generate
a ``coprocessor error'' exception when they're encountered.

\subsubsection{LWCn instructions}

``Load word coprocessor \emph{n}'' (LWC\emph{n}) opcodes are encoded
by setting bits [31:26] of the instruction \code{0x30}~+~\emph{n}.

\begin{lstlisting}
impl Cpu {
    //...

    /// Load Word in Coprocessor 0
    fn op_lwc0(&mut self, _: Instruction) {
        // Not supported by this coprocessor
        self.exception(Exception::CoprocessorError);
    }

    /// Load Word in Coprocessor 1
    fn op_lwc1(&mut self, _: Instruction) {
        // Not supported by this coprocessor
        self.exception(Exception::CoprocessorError);
    }

    /// Load Word in Coprocessor 2
    fn op_lwc2(&mut self, instruction: Instruction) {
        panic!("unhandled GTE LWC: {}", instruction);
    }

    /// Load Word in Coprocessor 3
    fn op_lwc3(&mut self, _: Instruction) {
        // Not supported by this coprocessor
        self.exception(Exception::CoprocessorError);
    }
}
\end{lstlisting}

\subsubsection{SWCn instructions}

``Store word coprocessor \emph{n}'' (SWC\emph{n}) opcodes are encoded
by setting bits [31:26] of the instruction \code{0x38}~+~\emph{n}.

\begin{lstlisting}
impl Cpu {
    //...

    /// Store Word in Coprocessor 0
    fn op_swc0(&mut self, _: Instruction) {
        // Not supported by this coprocessor
        self.exception(Exception::CoprocessorError);
    }

    /// Store Word in Coprocessor 1
    fn op_swc1(&mut self, _: Instruction) {
        // Not supported by this coprocessor
        self.exception(Exception::CoprocessorError);
    }

    /// Store Word in Coprocessor 2
    fn op_swc2(&mut self, instruction: Instruction) {
        panic!("unhandled GTE SWC: {}", instruction);
    }

    /// Store Word in Coprocessor 3
    fn op_swc3(&mut self, _: Instruction) {
        // Not supported by this coprocessor
        self.exception(Exception::CoprocessorError);
    }
}
\end{lstlisting}

\subsection{Illegal instructions}

We now have implemented (at least partially) all the CPU instructions!
That doesn't mean that our CPU is complete: we still have to implement
the GTE coprocessor and the cache for instance but that will wait for
later.

We can also take this opportunity to implement illegal
instructions. For instance instruction \code{0x50000000} doesn't
encode any valid instruction on the Playstation CPU and is therefore
illegal.

Illegal instructions simply trigger an exception on the CPU with the
code \code{0xa} in the CAUSE register.

Knowing that we can complete our \code{decode\_and\_execute} function,
here's what it should look like with all instructions implemented:

\begin{lstlisting}
impl Cpu {
    //...

    /// Decode `instruction`'s opcode and run the function
    fn decode_and_execute(&mut self, instruction: Instruction) {
        match instruction.function() {
            0b000000 => match instruction.subfunction() {
                0b000000 => self.op_sll(instruction),
                0b000010 => self.op_srl(instruction),
                0b000011 => self.op_sra(instruction),
                0b000100 => self.op_sllv(instruction),
                0b000110 => self.op_srlv(instruction),
                0b000111 => self.op_srav(instruction),
                0b001000 => self.op_jr(instruction),
                0b001001 => self.op_jalr(instruction),
                0b001100 => self.op_syscall(instruction),
                0b001101 => self.op_break(instruction),
                0b010000 => self.op_mfhi(instruction),
                0b010001 => self.op_mthi(instruction),
                0b010010 => self.op_mflo(instruction),
                0b010011 => self.op_mtlo(instruction),
                0b011000 => self.op_mult(instruction),
                0b011001 => self.op_multu(instruction),
                0b011010 => self.op_div(instruction),
                0b011011 => self.op_divu(instruction),
                0b100000 => self.op_add(instruction),
                0b100001 => self.op_addu(instruction),
                0b100010 => self.op_sub(instruction),
                0b100011 => self.op_subu(instruction),
                0b100100 => self.op_and(instruction),
                0b100101 => self.op_or(instruction),
                0b100110 => self.op_xor(instruction),
                0b100111 => self.op_nor(instruction),
                0b101010 => self.op_slt(instruction),
                0b101011 => self.op_sltu(instruction),
                _        => self.op_illegal(instruction),
            },
            0b000001 => self.op_bxx(instruction),
            0b000010 => self.op_j(instruction),
            0b000011 => self.op_jal(instruction),
            0b000100 => self.op_beq(instruction),
            0b000101 => self.op_bne(instruction),
            0b000110 => self.op_blez(instruction),
            0b000111 => self.op_bgtz(instruction),
            0b001000 => self.op_addi(instruction),
            0b001001 => self.op_addiu(instruction),
            0b001010 => self.op_slti(instruction),
            0b001011 => self.op_sltiu(instruction),
            0b001100 => self.op_andi(instruction),
            0b001101 => self.op_ori(instruction),
            0b001110 => self.op_xori(instruction),
            0b001111 => self.op_lui(instruction),
            0b010000 => self.op_cop0(instruction),
            0b010001 => self.op_cop1(instruction),
            0b010010 => self.op_cop2(instruction),
            0b010011 => self.op_cop3(instruction),
            0b100000 => self.op_lb(instruction),
            0b100001 => self.op_lh(instruction),
            0b100010 => self.op_lwl(instruction),
            0b100011 => self.op_lw(instruction),
            0b100100 => self.op_lbu(instruction),
            0b100101 => self.op_lhu(instruction),
            0b100110 => self.op_lwr(instruction),
            0b101000 => self.op_sb(instruction),
            0b101001 => self.op_sh(instruction),
            0b101010 => self.op_swl(instruction),
            0b101011 => self.op_sw(instruction),
            0b101110 => self.op_swr(instruction),
            0b110000 => self.op_lwc0(instruction),
            0b110001 => self.op_lwc1(instruction),
            0b110010 => self.op_lwc2(instruction),
            0b110011 => self.op_lwc3(instruction),
            0b111000 => self.op_swc0(instruction),
            0b111001 => self.op_swc1(instruction),
            0b111010 => self.op_swc2(instruction),
            0b111011 => self.op_swc3(instruction),
            _        => self.op_illegal(instruction),
        }
    }

    /// Illegal instruction
    fn op_illegal(&mut self, instruction: Instruction) {
        println!("Illegal instruction {}!", instruction);
        self.exception(Exception::IllegalInstruction);
    }
}

/// Exception types (as stored in the `CAUSE` register)
enum Exception {
    //...

   /// CPU encountered an unknown instruction
    IllegalInstruction = 0xa,
}
\end{lstlisting}

That's quite a milestone but it's only the beginning. While
implementing all those instructions and stepping through the BIOS
we've seen that it tries to use many peripherals: the SPU, the timers,
the DMA and the GPU in particular.

At this point my first objective is to display an image to the screen
so I want to start implementing the GPU as soon as possible. But we
won't be able to do anything useful with the GPU without the DMA, so
let's start with that.

\section{The DMA: Ordering tables and the GPU}

The \href{https://en.wikipedia.org/wiki/Direct_memory_access}{DMA} is
used to move data back and forth between the RAM and a peripheral
(GPU, CDROM, SPU, etc\dots{}). The CPU could achieve the same results
by a series of loads/stores but the DMA is generally much faster.

The Playstation DMA controller lives alongside the CPU and shares the
memory BUS with it. It means that while the DMA is busy transferring
data the CPU is stopped: only one device can access the BUS at a given
time. The DMA can only copy data between the RAM and a device, not
directly between two devices.  For instance you can't copy a texture
from the CDROM directly into the GPU with the DMA, you first have to
make a transfer from the CDROM into the main RAM and then a 2nd one
between the RAM and the GPU.

There are 7 DMA channels on the Playstation:

\begin{itemize}
\item Channel 0 is connected to the Media Decoder input
\item Channel 1 is connected to the Media Decoder output
\item Channel 2 is connected to the GPU
\item Channel 3 is connected to the CDROM drive
\item Channel 4 is connected to the SPU
\item Channel 5 is connected to the extension port
\item Channel 6 is only connected to the RAM and is used to clear an
  ``ordering table''
\end{itemize}


Implementing complete and accurate DMA support can be quite
tricky. The main problem is that in certain modes the DMA sporadically
gives back the control to the CPU. For instance while the GPU is busy
processing a command and won't accept any new input the DMA has to
wait. Instead of wasting time it gives back control to the CPU to give
it the opportunity to do something else.

In order to emulate this behaviour correctly we need to emulate the
GPU command FIFO, DMA timings and CPU timings correctly. Then we need
to setup the state machine to switch between the CPU and DMA when
needed. That would require quite some work to get right and we only
have the BIOS boot logo to test it at this point.

To avoid having to implement all that we're going to make a
simplifying assumption for now: when the DMA runs it does all the
transfer at once without giving back control to the CPU. This won't be
exactly accurate but it should suffice to run the BIOS and hopefully
some games.

The reason I feel confident doing this simplification is that PCSX-R
seems to do it that way and it can run quite many games, although some
comments hint that it breaks with certain titles and it uses some
hacks to improve compatibility. Mednafen on the other hand implements
a much accurate DMA and actually emulates the DMA giving back the
control to the CPU in certain situations, we'll probably want to do
something similar later on.

For now let's take a few steps back and revisit all the DMA register
reads and writes done by the BIOS so that we can emulate them
correctly.

\newpage

\listoftables

\end{document}
